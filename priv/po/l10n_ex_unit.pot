#. TRANSLATORS: def ExUnit.configuration()
#: lib/ex_unit.ex:201 
msgid ""
"Returns ExUnit configuration.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.DocTest.doctest(mod, opts \\ [])
#: lib/ex_unit/doc_test.ex:144 
msgid ""
"This macro is used to generate ExUnit test cases for doctests.\n"
"\n"
"Calling `doctest(Module)` will generate tests for all doctests found\n"
"in the module `Module`\n"
"\n"
"Options can also be supplied:\n"
"\n"
"  * `:except` — generate tests for all functions except those listed\n"
"    (list of `{function, arity}` tuples).\n"
"\n"
"  * `:only` — generate tests only for functions listed\n"
"    (list of `{function, arity}` tuples).\n"
"\n"
"  * `:import` — when true, one can test a function defined in the module\n"
"    without referring to the module name. However, this is not feasible when\n"
"    there is a clash with a module like Kernel. In these cases, `import`\n"
"    should be set to `false` and a full `M.f` construct should be used.\n"
"\n"
"## Examples\n"
"\n"
"    doctest MyModule, except: [trick_fun: 1]\n"
"\n"
"This macro is auto-imported with every `ExUnit.Case`.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:116 
msgid ""
"This is a negative assertion, failing if its parameter\n"
"is truthy.\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.start(options \\ [])
#: lib/ex_unit.ex:143 
msgid ""
"Starts ExUnit and automatically runs tests right before the\n"
"VM terminates. It accepts a set of options to configure `ExUnit`\n"
"(the same ones accepted by `configure/1`).\n"
"\n"
"If you want to run tests manually, you can set `:autorun` to `false`.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.configure(options)
#: lib/ex_unit.ex:192 
msgid ""
"Configures ExUnit.\n"
"\n"
"## Options\n"
"\n"
"ExUnit supports the following options:\n"
"\n"
"  * `:colors` - a keyword list of colors to be used by some formatters.\n"
"    The only option so far is `[enabled: boolean]` which defaults to `IO.ANSI.enabled?/1`\n"
"\n"
"  * `:formatters` - the formatters that will print results;\n"
"    defaults to `[ExUnit.CLIFormatter]`\n"
"\n"
"  * `:max_cases` - maximum number of cases to run in parallel;\n"
"    defaults to `:erlang.system_info(:schedulers_online)`\n"
"\n"
"  * `:trace` - set ExUnit into trace mode, this sets `:max_cases` to `1` and\n"
"    prints each test case and test while running\n"
"\n"
"  * `:autorun` - if ExUnit should run by default on exit; defaults to `true`\n"
"\n"
"  * `:include` - specify which tests are run by skipping tests that do not\n"
"    match the filter\n"
"\n"
"  * `:exclude` - specify which tests are run by skipping tests that match the\n"
"    filter\n"
"\n"
"  * `:seed` - an integer seed value to randomize the test suite\n"
msgstr ""
#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:12 
msgid ""
"Indicates no meaningful value for a field.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Formatter Summary
#: lib/ex_unit/formatter.ex:1 
msgid ""
"This module holds helper functions related to formatting and contains\n"
"documentation about the formatting protocol.\n"
"\n"
"Formatters are registered at the `ExUnit.EventManager` event manager and\n"
"will be send events by the runner.\n"
"\n"
"The following events are possible:\n"
"\n"
"  * `{:suite_started, opts}` -\n"
"        the suite has started with the specified options to the runner.\n"
"\n"
"  * `{:suite_finished, run_us, load_us}` -\n"
"        the suite has finished. `run_us` and `load_us` are the run and load\n"
"        times in microseconds respectively.\n"
"\n"
"  * `{:case_started, test_case}` -\n"
"        a test case has started. See `ExUnit.TestCase` for details.\n"
"\n"
"  * `{:case_finished, test_case}` -\n"
"        a test case has finished. See `ExUnit.TestCase` for details.\n"
"\n"
"  * `{:test_started, test_case}` -\n"
"        a test case has started. See `ExUnit.Test` for details.\n"
"\n"
"  * `{:test_finished, test_case}` -\n"
"        a test case has finished. See `ExUnit.Test` for details.\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:17 
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro tries to be smart\n"
"and provide good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns 13):\n"
"\n"
"   Comparison (using ==) failed in:\n"
"   code: some_fun() == 10\n"
"   lhs:  13\n"
"   rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle other\n"
"common cases such as checking a floating point number or handling exceptions.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:559 
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.CaseTemplate Summary
#: lib/ex_unit/case_template.ex:1 
msgid ""
"This module allows a developer to define a test case\n"
"template to be used throughout their tests. This is useful\n"
"when there are a set of functions that should be shared\n"
"between tests or a set of setup callbacks.\n"
"\n"
"By using this module, the callbacks and assertions\n"
"available for regular test cases will also be available.\n"
"\n"
"## Example\n"
"\n"
"    defmodule MyCase do\n"
"      use ExUnit.CaseTemplate\n"
"\n"
"      setup do\n"
"        IO.puts \"This will run before each test that uses this case\"\n"
"      end\n"
"    end\n"
"\n"
"    defmodule MyTest do\n"
"      use MyCase, async: true\n"
"\n"
"      test \"truth\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Case Summary
#: lib/ex_unit/case.ex:1 
msgid ""
"Sets up an ExUnit test case.\n"
"\n"
"This module must be used in other modules as a way to configure\n"
"and prepare them for testing.\n"
"\n"
"When used, it accepts the following options:\n"
"\n"
"  * :async - configure Elixir to run that specific test case in parallel with\n"
"    others. Must be used for performance when your test cases do not change\n"
"    any global state.\n"
"\n"
"This module automatically includes all callbacks defined in\n"
"`ExUnit.Callbacks`. See that module's documentation for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"     defmodule AssertionTest do\n"
"       # Use the module\n"
"       use ExUnit.Case, async: true\n"
"\n"
"       # The `test` macro is imported by ExUnit.Case\n"
"       test \"always pass\" do\n"
"         assert true\n"
"       end\n"
"     end\n"
"\n"
"## Context\n"
"\n"
"All tests receive a context as an argument. The context is particularly\n"
"useful for sharing information between callbacks and tests:\n"
"\n"
"    defmodule KVTest do\n"
"      use ExUnit.Case\n"
"\n"
"      setup do\n"
"        {:ok, pid} = KV.start_link\n"
"        {:ok, [pid: pid]}\n"
"      end\n"
"\n"
"      test \"stores key-values\", context do\n"
"        assert KV.put(context[:pid], :hello, :world) == :ok\n"
"        assert KV.get(context[:pid], :hello) == :world\n"
"      end\n"
"    end\n"
"\n"
"As the context is a map, it can be pattern matched on to extract\n"
"information:\n"
"\n"
"    test \"stores key-values\", %{pid: pid} do\n"
"      assert KV.put(pid, :hello, :world) == :ok\n"
"      assert KV.get(pid, :hello) == :world\n"
"    end\n"
"\n"
"## Tags\n"
"\n"
"The context is used to pass information from the callbacks to\n"
"the test. In order to pass information from the test to the\n"
"callback, ExUnit provides tags.\n"
"\n"
"By tagging a test, the tag value can be accessed in the context,\n"
"allowing the developer to customize the test. Let's see an\n"
"example:\n"
"\n"
"    defmodule FileTest do\n"
"      # Changing directory cannot be async\n"
"      use ExUnit.Case, async: false\n"
"\n"
"      setup context do\n"
"        # Read the :cd tag value\n"
"        if cd = context[:cd] do\n"
"          prev_cd = File.cwd!\n"
"          File.cd!(cd)\n"
"          on_exit fn -> File.cd!(prev_cd) end\n"
"        end\n"
"\n"
"        :ok\n"
"      end\n"
"\n"
"      @tag cd: \"fixtures\"\n"
"      test \"reads utf-8 fixtures\" do\n"
"        File.read(\"hello\")\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we have defined a tag called `:cd` that is\n"
"read in the setup callback to configure the working directory the\n"
"test is going to run on.\n"
"\n"
"Tags are also very effective when used with case templates\n"
"(`ExUnit.CaseTemplate`) allowing callbacks in the case template\n"
"to customize the test behaviour.\n"
"\n"
"Note a tag can be set in two different ways:\n"
"\n"
"    @tag key: value\n"
"    @tag :key       # equivalent to setting @tag key: true\n"
"\n"
"If a tag is given more than once, the last value wins.\n"
"\n"
"### Module tags\n"
"\n"
"A tag can be set for all tests in a module by setting `@moduletag`:\n"
"\n"
"    @moduletag :external\n"
"\n"
"If the same key is set via `@tag`, the `@tag` value has higher\n"
"precedence.\n"
"\n"
"### Known tags\n"
"\n"
"The following tags are set automatically by ExUnit and are\n"
"therefore reserved:\n"
"\n"
"  * `:case` - the test case module\n"
"  * `:test` - the test name\n"
"  * `:line` - the line on which the test was defined\n"
"  * `:file` - the file on which the test was defined\n"
"\n"
"The following tags customize how tests behaves:\n"
"\n"
"  * `:timeout` - customizes the test timeout in milliseconds (defaults to 30000)\n"
"\n"
"## Filters\n"
"\n"
"Tags can also be used to identify specific tests, which can then\n"
"be included or excluded using filters. The most common functionality\n"
"is to exclude some particular tests from running, which can be done\n"
"via `ExUnit.configure/1`:\n"
"\n"
"    # Exclude all external tests from running\n"
"    ExUnit.configure(exclude: [external: true])\n"
"\n"
"From now on, ExUnit will not run any test that has the `external` flag\n"
"set to true. This behaviour can be reversed with the `:include` option\n"
"which is usually passed through the command line:\n"
"\n"
"    mix test --include external:true\n"
"\n"
"Run `mix help test` for more information on how to run filters via Mix.\n"
"\n"
"Another use case for tags and filters is to exclude all tests that have\n"
"a particular tag by default, regardless of its value, and include only\n"
"a certain subset:\n"
"\n"
"    ExUnit.configure(exclude: :os, include: [os: :unix])\n"
"\n"
"Keep in mind that all tests are included by default, so unless they are\n"
"excluded first, the `include` option has no effect.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.normalize(include, exclude)
#: lib/ex_unit/filters.ex:39 
msgid ""
"Normalizes include and excludes to remove duplicates\n"
"and keep precedence.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.normalize(nil, nil)\n"
"    {[], []}\n"
"\n"
"    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n"
"    {[:foo, :bar], [:baz]}\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.CaptureIO Summary
#: lib/ex_unit/capture_io.ex:1 
msgid ""
"Functionality to capture IO for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test :example do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.eval(include, exclude, tags, collection)
#: lib/ex_unit/filters.ex:84 
msgid ""
"Evaluates the `include` and `exclude` filters against the given `tags`.\n"
"\n"
"Some filters, like `:line`, may require the whole test collection to\n"
"find the closest line, that's why it must also be passed as argument.\n"
"\n"
"Filters can either be a regular expression or any data structure\n"
"that implements to `String.Chars`, which is invoked before comparing\n"
"the filter with the tag value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n"
"    :ok\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n"
"    {:error, :foo}\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Formatter.format_test_case_failure(test_case, arg2, counter, width, formatter)
#: lib/ex_unit/formatter.ex:119 
msgid ""
"Receives a test case and formats its failure.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Formatter.format_test_failure(test, arg2, counter, width, formatter)
#: lib/ex_unit/formatter.ex:108 
msgid ""
"Receives a test and formats its failure.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Formatter.format_time(run_us, load_us)
#: lib/ex_unit/formatter.ex:63 
msgid ""
"Formats time taken running the test suite.\n"
"\n"
"It receives the time spent running the tests and\n"
"optionally the time spent loading the test suite.\n"
"\n"
"## Examples\n"
"\n"
"    iex> format_time(10000, nil)\n"
"    \"Finished in 0.01 seconds\"\n"
"\n"
"    iex> format_time(10000, 20000)\n"
"    \"Finished in 0.03 seconds (0.02s on load, 0.01s on tests)\"\n"
"\n"
"    iex> format_time(10000, 200000)\n"
"    \"Finished in 0.2 seconds (0.2s on load, 0.01s on tests)\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Formatter.format_filters(filters, type)
#: lib/ex_unit/formatter.ex:98 
msgid ""
"Formats filters used to constain cases to be run.\n"
"\n"
"## Examples\n"
"\n"
"  iex> format_filters([run: true, slow: false], :include)\n"
"  \"Including tags: [run: true, slow: false]\"\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Callbacks.setup(var \\ {:_, [], ExUnit.Callbacks}, block)
#: lib/ex_unit/callbacks.ex:108 
msgid ""
"Defines a callback to be run before each test in a case.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Callbacks.setup_all(var \\ {:_, [], ExUnit.Callbacks}, block)
#: lib/ex_unit/callbacks.ex:119 
msgid ""
"Defines a callback to be run before all tests in a case.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Callbacks.on_exit(ref \\ :erlang.make_ref(), callback)
#: lib/ex_unit/callbacks.ex:139 
msgid ""
"Defines a callback that runs on the test (or test case) exit.\n"
"\n"
"An `on_exit` callback is a function that receives no arguments and\n"
"runs in a separate process than the caller.\n"
"\n"
"`on_exit/2` is usually called from `setup` and `setup_all` callbacks,\n"
"often to undo the action performed during `setup`. However, `on_exit`\n"
"may also be called dynamically, where a reference can be used to\n"
"guarantee the callback will be invoked only once.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.parse(filters)
#: lib/ex_unit/filters.ex:55 
msgid ""
"Parses the given filters, as one would receive from the command line.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true\"])\n"
"    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Filters.parse_path(file)
#: lib/ex_unit/filters.ex:16 
msgid ""
"Parses filters out of a path.\n"
"\n"
"Determines whether a given file path (supplied to ExUnit/Mix as arguments\n"
"on the command line) includes a line number filter, and if so returns the\n"
"appropriate ExUnit configuration options.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.DocTest Summary
#: lib/ex_unit/doc_test.ex:1 
msgid ""
"ExUnit.DocTest implements functionality similar to [Python's\n"
"doctest](http://docs.python.org/2/library/doctest.html).\n"
"\n"
"In a nutshell, it allows us to generate tests from the code\n"
"examples existing in a module/function/macro's documentation.\n"
"In order to do that, one needs to invoke the `doctest/1` macro\n"
"from their test case and write their examples according\n"
"to some guidelines.\n"
"\n"
"The syntax for examples is as follows. Every new test starts\n"
"on a new line, with an `iex>` prefix. Multiline expressions\n"
"can be employed if the following lines start with either\n"
"`...>` (recommended) or `iex>` prefix.\n"
"\n"
"The expected result should start at the next line after `iex>`\n"
"or `...>` line(s) and is terminated either by a newline, new\n"
"`iex>` prefix or end of the string literal.\n"
"\n"
"## Examples\n"
"\n"
"Currently, the only way to run doctests is to include them into\n"
"an ExUnit case with a `doctest` macro:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"The `doctest` macro is going to loop through all functions and\n"
"macros defined in `MyModule`, parsing their documentation in\n"
"search of code examples.\n"
"\n"
"A very basic example is:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"Expressions on multiple lines are also supported:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2,4,6]\n"
"\n"
"Multiple results can be checked within the same test:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"If you want to keep any two tests separate,\n"
"add an empty line between them:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"function a/0 undefined\" error\n"
"    2\n"
"\n"
"Similarly to iex you can use numbers in your \"prompts\":\n"
"\n"
"    iex(1)> [1+2,\n"
"    ...(1)>  3]\n"
"    [3,3]\n"
"\n"
"This is useful in two use cases:\n"
"\n"
"  * being able to refer to specific numbered scenarios\n"
"  * copy-pasting examples from an actual iex session\n"
"\n"
"We also allow you to select or skip some functions when calling\n"
"`doctest`. See the documentation for more info.\n"
"\n"
"## Opaque types\n"
"\n"
"Some types internal structure are kept hidden and instead show a\n"
"user-friendly structure when inspecting the value. The idiom in\n"
"Elixir is to print those data types as `#Name<...>`. Doctest will\n"
"test these values by doing a string compare.\n"
"\n"
"    iex> Enum.into([a: 10, b: 20], HashDict.new)\n"
"    #HashDict<[b: 20, a: 10]>\n"
"\n"
"The above example will be tested with the following match:\n"
"`\"#HashDict<[b: 20, a: 10]>\" = inspect(Enum.into([a: 10, b: 20], HashDict.new))`.\n"
"\n"
"## Exceptions\n"
"\n"
"You can also showcase expressions raising an exception, for example:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"What DocTest will be looking for is a line starting with `** (` and it\n"
"will parse it accordingly to extract the exception name and message.\n"
"At this moment, the exception parser would make the parser treat the next\n"
"line as a start of a completely new expression (if it is prefixed with `iex>`)\n"
"or a no-op line with documentation. Thus, multiline messages are not\n"
"supported.\n"
"\n"
"## When not to use doctest\n"
"\n"
"In general, doctests are not recommended when your code examples contain\n"
"side effects. For example, if a doctest prints to standard output, doctest\n"
"will not try to capture the output.\n"
"\n"
"Similarly, doctests do not run in any kind of sandbox. So any module\n"
"defined in a code example is going to linger throughout the whole test\n"
"suite run.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Callbacks Summary
#: lib/ex_unit/callbacks.ex:1 
msgid ""
"Defines ExUnit Callbacks.\n"
"\n"
"This module defines both `setup_all` and `setup` callbacks, as well as\n"
"the `on_exit` facility.\n"
"\n"
"The setup callbacks are defined via macros and each one can optionally\n"
"receive a map with metadata, usually referred to as `context`. The\n"
"callback may optionally put extra data into `context` to be used in\n"
"the tests.\n"
"\n"
"The `setup_all` callbacks are invoked once before the first test's `setup`\n"
"and all `setup` callbacks are run before each test. No callback runs if the\n"
"test case has no tests or all tests were filtered out.\n"
"\n"
"`on_exit` callbacks are registered on demand, usually to undo an action\n"
"performed by a setup callback. `on_exit` may also take a reference,\n"
"allowing callback to be overridden in the future. A registered `on_exit`\n"
"callback always runs, while failures in `setup` and `setup_all` will stop\n"
"all remaining setup callbacks from executing.\n"
"\n"
"Finally, `setup_all` callbacks run in the test case process, while all\n"
"`setup` callbacks run in the same process as the test itself. `on_exit`\n"
"callbacks always run in a separate process than the test case or the\n"
"test itself. Since the test process exits with reason `:shutdown`, most\n"
"of times `on_exit/1` can be avoided as processes are going to clean\n"
"up on their own.\n"
"\n"
"## Context\n"
"\n"
"If you return `{:ok, <dict>}` from `setup_all`, the dictionary\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup_all`, `setup` and the test itself.\n"
"\n"
"Similarly, returning `{:ok, <dict>}` from `setup`, the dict returned\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup` and the `test` itself.\n"
"\n"
"Returning `:ok` leaves the context unchanged in both cases.\n"
"\n"
"Returning anything else from `setup_all` will force all tests to fail,\n"
"while a bad response from `setup` causes the current test to fail.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # `setup_all` is called once before every test\n"
"      setup_all do\n"
"        IO.puts \"Starting AssertionTest\"\n"
"\n"
"        # No metadata\n"
"        :ok\n"
"      end\n"
"\n"
"      # `setup` is called before each test is run\n"
"      setup do\n"
"        IO.puts \"This is a setup callback\"\n"
"\n"
"        on_exit fn ->\n"
"          IO.puts \"This is invoked once the test is done\"\n"
"        end\n"
"\n"
"        # Returns extra metadata, it must be a dict\n"
"        {:ok, hello: \"world\"}\n"
"      end\n"
"\n"
"      # Same as `setup`, but receives the context\n"
"      # for the current test\n"
"      setup context do\n"
"        IO.puts \"Setting up: #{context[:test]}\"\n"
"        :ok\n"
"      end\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"\n"
"      test \"another one\", context do\n"
"        assert context[:hello] == \"world\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit Summary
#: lib/ex_unit.ex:1 
msgid ""
"Basic unit testing framework for Elixir.\n"
"\n"
"## Example\n"
"\n"
"A basic setup for ExUnit is shown below:\n"
"\n"
"    # File: assertion_test.exs\n"
"\n"
"    # 1) Start ExUnit.\n"
"    ExUnit.start\n"
"\n"
"    # 2) Create a new test module (test case) and use `ExUnit.Case`.\n"
"    defmodule AssertionTest do\n"
"      # 3) Notice we pass `async: true`, this runs the test case\n"
"      #    concurrently with other test cases\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # 4) Use the `test` macro instead of `def` for clarity.\n"
"      test \"the truth\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"To run the tests above, run the file\n"
"using `elixir` from the command line. Assuming you named the file\n"
"`assertion_test.exs`, you can run it as:\n"
"\n"
"    bin/elixir assertion_test.exs\n"
"\n"
"## Case, Callbacks and Assertions\n"
"\n"
"See `ExUnit.Case` and `ExUnit.Callbacks`\n"
"for more information about defining test cases.\n"
"\n"
"The `ExUnit.Assertions` module contains\n"
"a set of macros to easily generate assertions with appropriate\n"
"error messages.\n"
"\n"
"## Integration with Mix\n"
"\n"
"Mix is the project management and build tool for Elixir. Invoking `mix test`\n"
"from the command line will run the tests in each file matching the pattern\n"
"`*_test.exs` found in the `test` directory of your project.\n"
"\n"
"You must create a `test_helper.exs` file inside the\n"
"`test` directory and put the code common to all tests there.\n"
"\n"
"The minimum example of a `test_helper.exs` file would be:\n"
"\n"
"    # test/test_helper.exs\n"
"    ExUnit.start\n"
"\n"
"Mix will load the `test_helper.exs` file before executing the tests.\n"
"It is not necessary to `require` the `test_helper.exs` file in your test\n"
"files. See `Mix.Tasks.Test` for more information.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:358 
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:332 
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the `expected_message`. Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", fn ->\n"
"      1 + \"test\"\n"
"    end\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:389 
msgid ""
"Asserts that `val1` and `val2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:66 
msgid ""
"Asserts its argument is true.\n"
"\n"
"`assert` tries to be smart and provide good\n"
"reporting whenever there is a failure. In particular, if\n"
"given a match expression, it will report any failure in terms\n"
"of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"If the expression is a comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(expected, message \\ nil)
#: lib/ex_unit/assertions.ex:270 
msgid ""
"Asserts a message was received and is in the current process' mailbox.\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:249 
msgid ""
"Asserts a message was or is going to be received. Unlike\n"
"`assert_received`, it has a default timeout of 100 milliseconds.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.CaptureIO.capture_io(fun)
#: lib/ex_unit/capture_io.ex:62 
msgid ""
"Captures IO generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"By default, `capture_io` replaces the `group_leader` (`:stdio`)\n"
"for the current process. However, the capturing of any other\n"
"named device, such as `:stderr`, is also possible globally by\n"
"giving the registered device name explicitly as an argument.\n"
"\n"
"Note that when capturing something other than `:stdio`,\n"
"the test should run with async false.\n"
"\n"
"When capturing `:stdio`, if the `:capture_prompt` option is `false`,\n"
"prompts (specified as arguments to `IO.get*` functions) are not\n"
"captured.\n"
"\n"
"A developer can set a string as an input. The default\n"
"input is `:eof`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(not_expected, message \\ nil)
#: lib/ex_unit/assertions.ex:495 
msgid ""
"Asserts a message was not received (i.e. it is not in the current process mailbox).\n"
"The `not_expected` argument must be a match pattern.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert(value, left, right, message)
#: lib/ex_unit/assertions.ex:223 
msgid ""
"Asserts `value` is true.\n"
"If it fails, it raises an expectation error\n"
"using the given `left` and `right` values.\n"
"\n"
"You probably don't need to use this—the regular `assert` function\n"
"handles this for you.\n"
"\n"
"## Examples\n"
"\n"
"    assert this > that, this, that, \"more than\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:201 
msgid ""
"Asserts `value` is true, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:458 
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:537 
msgid ""
"Asserts `val1` and `val2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:406 
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:419 
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:432 
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.run()
#: lib/ex_unit.ex:212 
msgid ""
"API used to run the tests. It is invoked automatically\n"
"if ExUnit is started via `ExUnit.start/1`.\n"
"\n"
"Returns a map containing the total number of tests, the number\n"
"of failures and the number of skipped tests.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(not_expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:479 
msgid ""
"    refute_receive message, timeout \\ 100, message \\ nil\n"
"\n"
"Asserts `message` was not received (and won't be received) within\n"
"the `timeout` period.\n"
"\n"
"The `not_expected` argument is a match pattern.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with a explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Case.test(message, var \\ {:_, [], ExUnit.Case}, contents)
#: lib/ex_unit/case.ex:202 
msgid ""
"Define a test with a string.\n"
"\n"
"Provides a convenient macro that allows a test to be\n"
"defined with a string. This macro automatically inserts\n"
"the atom `:ok` as the last line of the test. That said,\n"
"a passing test always returns `:ok`, but, more importantly,\n"
"it forces Elixir to not tail call optimize the test and\n"
"therefore avoids hiding lines from the backtrace.\n"
"\n"
"## Examples\n"
"\n"
"    test \"true is equal to true\" do\n"
"      assert true == true\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.CaseTemplate.using(var \\ {:_, [], ExUnit.CaseTemplate}, list2)
#: lib/ex_unit/case_template.ex:66 
msgid ""
"Allows a developer to customize the using block\n"
"when the case template is used.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Filters Summary
#: lib/ex_unit/filters.ex:1 
msgid ""
"Conveniences for parsing and evaluating filters.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Test Summary
#: lib/ex_unit.ex:64 
msgid ""
"A struct that keeps information about the test.\n"
"\n"
"It is received by formatters and contains the following fields:\n"
"\n"
"  * `:name`  - the test name\n"
"  * `:case`  - the test case\n"
"  * `:state` - the test state (see ExUnit.state)\n"
"  * `:time`  - the time to run the test\n"
"  * `:tags`  - the test tags\n"
"\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.TestCase Summary
#: lib/ex_unit.ex:91 
msgid ""
"A struct that keeps information about the test case.\n"
"\n"
"It is received by formatters and contains the following fields:\n"
"\n"
"  * `:name`  - the test case name\n"
"  * `:state` - the test state (see ExUnit.state)\n"
"  * `:tests` - all tests for this case\n"
"\n"
msgstr ""
