msgid ""
msgstr ""
"Project-Id-Version: l 10n_ex_unit\n"
"PO-Revision-Date: 2015-01-03 20:02+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def ExUnit.configuration()
#: lib/ex_unit.ex:201
msgid "Returns ExUnit configuration.\n"
msgstr "ExUnitコンフィグレーションを返します。\n"

#. TRANSLATORS: defmacro ExUnit.DocTest.doctest(mod, opts \\ [])
#: lib/ex_unit/doc_test.ex:144
msgid ""
"This macro is used to generate ExUnit test cases for doctests.\n"
"\n"
"Calling `doctest(Module)` will generate tests for all doctests found\n"
"in the module `Module`\n"
"\n"
"Options can also be supplied:\n"
"\n"
"  * `:except` — generate tests for all functions except those listed\n"
"    (list of `{function, arity}` tuples).\n"
"\n"
"  * `:only` — generate tests only for functions listed\n"
"    (list of `{function, arity}` tuples).\n"
"\n"
"  * `:import` — when true, one can test a function defined in the module\n"
"    without referring to the module name. However, this is not feasible "
"when\n"
"    there is a clash with a module like Kernel. In these cases, `import`\n"
"    should be set to `false` and a full `M.f` construct should be used.\n"
"\n"
"## Examples\n"
"\n"
"    doctest MyModule, except: [trick_fun: 1]\n"
"\n"
"This macro is auto-imported with every `ExUnit.Case`.\n"
msgstr ""
"このマクロはdoctestのためのExUnitテストケースを生成するために使\n"
"われます。\n"
"\n"
"`doctest(Module)`を呼ぶと、モジュール`Module`に見付かった、\n"
"全てのdoctestのためのテストを生成します。\n"
"\n"
"以下のオプションも提供されます:\n"
"\n"
"  * `:except` —  リストされた関数を除外してテストを生成します\n"
"          (リストは`{function, arity}`タプルのリストです)。\n"
"\n"
"  * `:only` — リストされた関数のみのテストを生成します\n"
"          (リストは`{function, arity}`タプルのリストです)。\n"
"\n"
"  * `:import` — trueのとき、モジュール名を参照することなく、\n"
"     モジュールで定義された関数をテストすることができます。\n"
"     しかしながら、Kernelのようなモジュールとの衝突があるとき、\n"
"     これは可能ではありません。このような場合、`import`は`false`に\n"
"     セットし、完全な`M.f`文法が使われなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    doctest MyModule, except: [trick_fun: 1]\n"
"\n"
"このマクロは、`ExUnit.Case`毎に自動的にインポートされます。\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:116
msgid ""
"This is a negative assertion, failing if its parameter\n"
"is truthy.\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
"これは否定的なアサーションで、パラメタがtrueなら失敗します。\n"
"\n"
"## 例\n"
"\n"
"    refute age < 0\n"
"\n"

#. TRANSLATORS: def ExUnit.start(options \\ [])
#: lib/ex_unit.ex:143
msgid ""
"Starts ExUnit and automatically runs tests right before the\n"
"VM terminates. It accepts a set of options to configure `ExUnit`\n"
"(the same ones accepted by `configure/1`).\n"
"\n"
"If you want to run tests manually, you can set `:autorun` to `false`.\n"
msgstr ""
"ExUnitを開始し、自動的にテストを走らせ、直後にVMを終了します。\n"
"`ExUnit`を構成するための、一組のオプションを受け入れます\n"
"(オプションは`configure/1`と同じです)。\n"
"\n"
"マニュルでテストを走らせたいなら、`:autorun`を`false`にセット\n"
"してください。\n"

#. TRANSLATORS: def ExUnit.configure(options)
#: lib/ex_unit.ex:192
msgid ""
"Configures ExUnit.\n"
"\n"
"## Options\n"
"\n"
"ExUnit supports the following options:\n"
"\n"
"  * `:colors` - a keyword list of colors to be used by some formatters.\n"
"    The only option so far is `[enabled: boolean]` which defaults to `IO."
"ANSI.enabled?/1`\n"
"\n"
"  * `:formatters` - the formatters that will print results;\n"
"    defaults to `[ExUnit.CLIFormatter]`\n"
"\n"
"  * `:max_cases` - maximum number of cases to run in parallel;\n"
"    defaults to `:erlang.system_info(:schedulers_online)`\n"
"\n"
"  * `:trace` - set ExUnit into trace mode, this sets `:max_cases` to `1` "
"and\n"
"    prints each test case and test while running\n"
"\n"
"  * `:autorun` - if ExUnit should run by default on exit; defaults to "
"`true`\n"
"\n"
"  * `:include` - specify which tests are run by skipping tests that do not\n"
"    match the filter\n"
"\n"
"  * `:exclude` - specify which tests are run by skipping tests that match "
"the\n"
"    filter\n"
"\n"
"  * `:seed` - an integer seed value to randomize the test suite\n"
msgstr ""
"ExUnitを構成します。\n"
"\n"
"## オプション\n"
"\n"
"ExUnitは以下のオプションをサポートします:\n"
"\n"
"  * `:colors` - いくつかのフォーマッタで使われる色のキーワード\n"
"    リストです。今のところ唯一のオプションは、デフォルトで\n"
"    `IO.ANSI.enabled?/1`になる、`[enabled: boolean]`です。\n"
"\n"
"  * `:formatters` - 結果をプリントするフォーマッタで、デフォルトは\n"
"    `[ExUnit.CLIFormatter]`です\n"
"\n"
"  * `:max_cases` - 並行して走らせるテストケースの最大数で、\n"
"    デフォルトは`:erlang.system_info(:schedulers_online)`です\n"
"\n"
"  * `:trace` - ExUnitをtraceモードにセットします; これは\n"
"    `:max_case`を`1`にし、動作中のそれぞれのテストケースと\n"
"    テストをプリントします\n"
"\n"
"  * `:autorun` - ExUnitをon exit(終了直前)に実行すべきかどうかです; \n"
"    デフォルトは`true`です\n"
"\n"
"  * `:include` - 指定したフィルタにマッチしないテストをスキップする\n"
"    ようにします。\n"
"\n"
"  * `:exclude` - 指定したフィルタにマッチしたテストをスキップする\n"
"    ようにします。\n"
"\n"
"  * `:seed` - テストスイートの乱数シードの整数を指定します\n"

#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:12
msgid "Indicates no meaningful value for a field.\n"
msgstr "フィールドに意味のある値が無いことを示します。\n"

#. TRANSLATORS: Elixir.ExUnit.Formatter Summary
#: lib/ex_unit/formatter.ex:1
msgid ""
"This module holds helper functions related to formatting and contains\n"
"documentation about the formatting protocol.\n"
"\n"
"Formatters are registered at the `ExUnit.EventManager` event manager and\n"
"will be send events by the runner.\n"
"\n"
"The following events are possible:\n"
"\n"
"  * `{:suite_started, opts}` -\n"
"        the suite has started with the specified options to the runner.\n"
"\n"
"  * `{:suite_finished, run_us, load_us}` -\n"
"        the suite has finished. `run_us` and `load_us` are the run and load\n"
"        times in microseconds respectively.\n"
"\n"
"  * `{:case_started, test_case}` -\n"
"        a test case has started. See `ExUnit.TestCase` for details.\n"
"\n"
"  * `{:case_finished, test_case}` -\n"
"        a test case has finished. See `ExUnit.TestCase` for details.\n"
"\n"
"  * `{:test_started, test_case}` -\n"
"        a test case has started. See `ExUnit.Test` for details.\n"
"\n"
"  * `{:test_finished, test_case}` -\n"
"        a test case has finished. See `ExUnit.Test` for details.\n"
"\n"
msgstr ""
"このモジュールは、フォーマット関連のヘルパー関数を保持し、\n"
"フォーマットプロトコルについてのドキュメントを含みます。\n"
"\n"
"フォーマッタは`ExUnit.EventManager`イベントマネージャで\n"
"登録されrunnerによりイベントが送信されます。\n"
"\n"
"以下のイベントが可能です:\n"
"\n"
"  * `{:suite_started, opts}` -\n"
"        suiteはrunnerに指定されたオプションで開始しました。\n"
"\n"
"  * `{:suite_finished, run_us, load_us}` -\n"
"        suiteは終了しました。`run_us`と`load_us`は、それぞれ、\n"
"        runとloadの時間で、単位はマイクロ秒です。\n"
"\n"
"  * `{:case_started, test_case}` -\n"
"        テストケースは開始しました。\n"
"        詳細は、`ExUnit.TestCase`を参照してください。\n"
"\n"
"  * `{:case_finished, test_case}` -\n"
"        テストケースは終了しました。\n"
"        詳細は、`ExUnit.TestCase`を参照してください。\n"
"\n"
"  * `{:test_started, test_case}` -\n"
"        テストは開始しました。\n"
"        詳細は、`ExUnit.Test`を参照してください。\n"
"\n"
"  * `{:test_finished, test_case}` -\n"
"        テストは終了しました。\n"
"        詳細は、`ExUnit.Test`を参照してください。\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:17
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro tries to be smart\n"
"and provide good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns 13):\n"
"\n"
"   Comparison (using ==) failed in:\n"
"   code: some_fun() == 10\n"
"   lhs:  13\n"
"   rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle other\n"
"common cases such as checking a floating point number or handling "
"exceptions.\n"
msgstr ""
"このモジュールは一組のアサーション関数を含み、\n"
"デフォルトでテストケースにインポートされます。\n"
"\n"
"一般に、開発者はテストにおいて、一般的な`assert`マクロを\n"
"使いたい。このマクロは、失敗したときは何時でも、\n"
"スマートでよいレポートを提供するようとします。\n"
"例えば、`assert sum_fun() == 10`が失敗すると(\n"
"`sum_fun()`が13を返したとします):\n"
"\n"
"   Comparison (using ==) failed in:\n"
"   code: some_fun() == 10\n"
"   lhs:  13\n"
"   rhs:  10\n"
"\n"
"このモジュールは、浮動小数点数のチェックや例外の\n"
"ハンドリングといった他の共通のケースを簡単に扱う、\n"
"`assert_in_delta`や`assert_raise`\n"
"のような、他の便利な関数も提供します。\n"

#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:559
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
"メッセージ付きで失敗します。\n"
"\n"
"## 例\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.CaseTemplate Summary
#: lib/ex_unit/case_template.ex:1
msgid ""
"This module allows a developer to define a test case\n"
"template to be used throughout their tests. This is useful\n"
"when there are a set of functions that should be shared\n"
"between tests or a set of setup callbacks.\n"
"\n"
"By using this module, the callbacks and assertions\n"
"available for regular test cases will also be available.\n"
"\n"
"## Example\n"
"\n"
"    defmodule MyCase do\n"
"      use ExUnit.CaseTemplate\n"
"\n"
"      setup do\n"
"        IO.puts \"This will run before each test that uses this case\"\n"
"      end\n"
"    end\n"
"\n"
"    defmodule MyTest do\n"
"      use MyCase, async: true\n"
"\n"
"      test \"truth\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"このモジュールは、開発者に、テストを通して使われる\n"
"ための、テストケーステンプレートの定義を許します。\n"
"テストの間で共有されなければならない関数、または、\n"
"一組のセットアップコールバックがある時、これは\n"
"役に立ちます。\n"
"\n"
"このモジュールを用いて、標準のテストケース\n"
"が利用できる、コールバックとアサーションもまた有効\n"
"になります。\n"
"\n"
"## 例\n"
"\n"
"    defmodule MyCase do\n"
"      use ExUnit.CaseTemplate\n"
"\n"
"      setup do\n"
"        IO.puts \"This will run before each test that uses this case\"\n"
"      end\n"
"    end\n"
"\n"
"    defmodule MyTest do\n"
"      use MyCase, async: true\n"
"\n"
"      test \"truth\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.Case Summary
#: lib/ex_unit/case.ex:1
msgid ""
"Sets up an ExUnit test case.\n"
"\n"
"This module must be used in other modules as a way to configure\n"
"and prepare them for testing.\n"
"\n"
"When used, it accepts the following options:\n"
"\n"
"  * :async - configure Elixir to run that specific test case in parallel "
"with\n"
"    others. Must be used for performance when your test cases do not change\n"
"    any global state.\n"
"\n"
"This module automatically includes all callbacks defined in\n"
"`ExUnit.Callbacks`. See that module's documentation for more\n"
"information.\n"
"\n"
"## Examples\n"
"\n"
"     defmodule AssertionTest do\n"
"       # Use the module\n"
"       use ExUnit.Case, async: true\n"
"\n"
"       # The `test` macro is imported by ExUnit.Case\n"
"       test \"always pass\" do\n"
"         assert true\n"
"       end\n"
"     end\n"
"\n"
"## Context\n"
"\n"
"All tests receive a context as an argument. The context is particularly\n"
"useful for sharing information between callbacks and tests:\n"
"\n"
"    defmodule KVTest do\n"
"      use ExUnit.Case\n"
"\n"
"      setup do\n"
"        {:ok, pid} = KV.start_link\n"
"        {:ok, [pid: pid]}\n"
"      end\n"
"\n"
"      test \"stores key-values\", context do\n"
"        assert KV.put(context[:pid], :hello, :world) == :ok\n"
"        assert KV.get(context[:pid], :hello) == :world\n"
"      end\n"
"    end\n"
"\n"
"As the context is a map, it can be pattern matched on to extract\n"
"information:\n"
"\n"
"    test \"stores key-values\", %{pid: pid} do\n"
"      assert KV.put(pid, :hello, :world) == :ok\n"
"      assert KV.get(pid, :hello) == :world\n"
"    end\n"
"\n"
"## Tags\n"
"\n"
"The context is used to pass information from the callbacks to\n"
"the test. In order to pass information from the test to the\n"
"callback, ExUnit provides tags.\n"
"\n"
"By tagging a test, the tag value can be accessed in the context,\n"
"allowing the developer to customize the test. Let's see an\n"
"example:\n"
"\n"
"    defmodule FileTest do\n"
"      # Changing directory cannot be async\n"
"      use ExUnit.Case, async: false\n"
"\n"
"      setup context do\n"
"        # Read the :cd tag value\n"
"        if cd = context[:cd] do\n"
"          prev_cd = File.cwd!\n"
"          File.cd!(cd)\n"
"          on_exit fn -> File.cd!(prev_cd) end\n"
"        end\n"
"\n"
"        :ok\n"
"      end\n"
"\n"
"      @tag cd: \"fixtures\"\n"
"      test \"reads utf-8 fixtures\" do\n"
"        File.read(\"hello\")\n"
"      end\n"
"    end\n"
"\n"
"In the example above, we have defined a tag called `:cd` that is\n"
"read in the setup callback to configure the working directory the\n"
"test is going to run on.\n"
"\n"
"Tags are also very effective when used with case templates\n"
"(`ExUnit.CaseTemplate`) allowing callbacks in the case template\n"
"to customize the test behaviour.\n"
"\n"
"Note a tag can be set in two different ways:\n"
"\n"
"    @tag key: value\n"
"    @tag :key       # equivalent to setting @tag key: true\n"
"\n"
"If a tag is given more than once, the last value wins.\n"
"\n"
"### Module tags\n"
"\n"
"A tag can be set for all tests in a module by setting `@moduletag`:\n"
"\n"
"    @moduletag :external\n"
"\n"
"If the same key is set via `@tag`, the `@tag` value has higher\n"
"precedence.\n"
"\n"
"### Known tags\n"
"\n"
"The following tags are set automatically by ExUnit and are\n"
"therefore reserved:\n"
"\n"
"  * `:case` - the test case module\n"
"  * `:test` - the test name\n"
"  * `:line` - the line on which the test was defined\n"
"  * `:file` - the file on which the test was defined\n"
"\n"
"The following tags customize how tests behaves:\n"
"\n"
"  * `:timeout` - customizes the test timeout in milliseconds (defaults to "
"30000)\n"
"\n"
"## Filters\n"
"\n"
"Tags can also be used to identify specific tests, which can then\n"
"be included or excluded using filters. The most common functionality\n"
"is to exclude some particular tests from running, which can be done\n"
"via `ExUnit.configure/1`:\n"
"\n"
"    # Exclude all external tests from running\n"
"    ExUnit.configure(exclude: [external: true])\n"
"\n"
"From now on, ExUnit will not run any test that has the `external` flag\n"
"set to true. This behaviour can be reversed with the `:include` option\n"
"which is usually passed through the command line:\n"
"\n"
"    mix test --include external:true\n"
"\n"
"Run `mix help test` for more information on how to run filters via Mix.\n"
"\n"
"Another use case for tags and filters is to exclude all tests that have\n"
"a particular tag by default, regardless of its value, and include only\n"
"a certain subset:\n"
"\n"
"    ExUnit.configure(exclude: :os, include: [os: :unix])\n"
"\n"
"Keep in mind that all tests are included by default, so unless they are\n"
"excluded first, the `include` option has no effect.\n"
msgstr ""
"ExUnitテストケースをセットアップします。\n"
"\n"
"テストの構成と準備をさせる方法として、このモジュールが、\n"
"他のモジュールで使われなければなりません。\n"
"\n"
"使われるとき、以下のオプションを受入ます:\n"
"\n"
"  * :async - Elixirを他と並列に特定のテストケースを走らせるよう\n"
"    構成します。そのテストが全くグローバルステートを変更しないとき、\n"
"    パフォーマンスのために使われなければなりません。\n"
"\n"
"このモジュールは、`ExUnit.Callbacks`で定義された、\n"
"全てのコールバックを自動的に含みます。詳細はそのモジュール\n"
"ドキュメントを参照してください。\n"
"\n"
"## 例\n"
"\n"
"     defmodule AssertionTest do\n"
"       # Use the module\n"
"       use ExUnit.Case, async: true\n"
"\n"
"       # The `test` macro is imported by ExUnit.Case\n"
"       test \"always pass\" do\n"
"         assert true\n"
"       end\n"
"     end\n"
"\n"
"## コンテキスト\n"
"\n"
"全てのテストは、引数としてコンテキストを受け取ります。コンテキストは\n"
"特にコールバックとテストの間で情報を共有するために役立ちます:\n"
"\n"
"    defmodule KVTest do\n"
"      use ExUnit.Case\n"
"\n"
"      setup do\n"
"        {:ok, pid} = KV.start_link\n"
"        {:ok, [pid: pid]}\n"
"      end\n"
"\n"
"      test \"stores key-values\", context do\n"
"        assert KV.put(context[:pid], :hello, :world) == :ok\n"
"        assert KV.get(context[:pid], :hello) == :world\n"
"      end\n"
"    end\n"
"\n"
"コンテキストはマップなので、情報の抽出にパターンマッチングを\n"
"使うことができます:\n"
"\n"
"    test \"stores key-values\", %{pid: pid} do\n"
"      assert KV.put(pid, :hello, :world) == :ok\n"
"      assert KV.get(pid, :hello) == :world\n"
"    end\n"
"\n"
"## タグ\n"
"\n"
"コンテキストはコールバックからテストへ情報を渡すために使わ\n"
"れます。テストからコールバックへ情報を渡すために、ExUnitは\n"
"タグを提供します。\n"
"\n"
"テストにタグを付けることで、タグの値はコンテキストでアクセス\n"
"可能になり、開発者にテストをカスタマイズすることを許します。\n"
"例を見ましょう:\n"
"\n"
"    defmodule FileTest do\n"
"      # Changing directory cannot be async\n"
"      use ExUnit.Case, async: false\n"
"\n"
"      setup context do\n"
"        # Read the :cd tag value\n"
"        if cd = context[:cd] do\n"
"          prev_cd = File.cwd!\n"
"          File.cd!(cd)\n"
"          on_exit fn -> File.cd!(prev_cd) end\n"
"        end\n"
"\n"
"        :ok\n"
"      end\n"
"\n"
"      @tag cd: \"fixtures\"\n"
"      test \"reads utf-8 fixtures\" do\n"
"        File.read(\"hello\")\n"
"      end\n"
"    end\n"
"\n"
"上の例では、テストが走る作業ディレクトリを構成するために、\n"
"セットアップコールバックで読まれる、`:cd`と呼ばれるタグを\n"
"定義しました。\n"
"\n"
"ケーステンプレートのコールバックに\n"
"テストの振舞いをカスタマイズすることを許す、\n"
"ケーステンプレート(`ExUnit.CaseTemplates`)と一緒に使うとき、\n"
"タグも非常に効果的です。\n"
"\n"
"タグは二つの異る方法でセット出来ることに気を付けてください:\n"
"\n"
"    @tag key: value\n"
"    @tag :key       # @tag key: true と同じです\n"
"\n"
"もしタグが一つ以上与えられたら、最後の値が勝ちます。\n"
"\n"
"### モジュールタグ\n"
"\n"
"`@moduletag`のセットにより、モジュールの全てのテストのために、\n"
"タグをセットすることが出来ます:\n"
"タグ\n"
"    @moduletag :external\n"
"\n"
"もし同じキーが`@tag`によりセットされたら、`@tag`の値が\n"
"より高い優先順位をもちます。\n"
"\n"
"### Known tags\n"
"\n"
"以下のタグはExUnitにより自動的にセットされるので、\n"
"予約されています:\n"
"\n"
"  * `:case` - テストケースモジュール\n"
"  * `:test` - テスト名\n"
"  * `:line` - テストが定義された行\n"
"  * `:file` - テストが定義されたファイル\n"
"\n"
"以下のタグはテストがどのように振る舞うかを\n"
"カスタマイズします:\n"
"\n"
"  * `:timeout` - テストのタイムアウトをミリ秒でカスタマイズします\n"
"    (デフォルトは30000)\n"
"\n"
"## フィルタ\n"
"\n"
"タグは、特定のテストを識別するために使うこともできます。\n"
"それにより、フィルタを使って含むか除外するの指定ができます。\n"
"最も一般的な機能は、`ExUnit.configure/1`により\n"
"可能な、テスト実行時に特定のテストを除外することです:\n"
"\n"
"    # Exclude all external tests from running\n"
"    ExUnit.configure(exclude: [external: true])\n"
"\n"
"今後、ExUnitは`external`フラグがtrueとなる全てのテストは実\n"
"行しません。この振舞いは、通常`:include`オプションを\n"
"コマンドラインから渡すことで反転できます:\n"
"\n"
"    mix test --include external:true\n"
"\n"
"Mixによりフィルタを実行する方法の詳細は、\n"
"`mix help test`を実行してください。\n"
"\n"
"タグとフィルタのもう一つのユースケースは、値に関係なく、\n"
"デフォルトで全てのテストを除外する特定のタグがあり、\n"
"特定のサブセットだけを含む場合です:\n"
"\n"
"    ExUnit.configure(exclude: :os, include: [os: :unix])\n"
"\n"
"全てのテストはデフォルトで含まれているため、\n"
"それらが最初に除外されない限り、`include`オプションは\n"
"効果がない事を心に留めておいてください。\n"

#. TRANSLATORS: def ExUnit.Filters.normalize(include, exclude)
#: lib/ex_unit/filters.ex:39
msgid ""
"Normalizes include and excludes to remove duplicates\n"
"and keep precedence.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.normalize(nil, nil)\n"
"    {[], []}\n"
"\n"
"    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n"
"    {[:foo, :bar], [:baz]}\n"
"\n"
msgstr ""
"優先度を保ち、重複を除去して、includeとexcludeを正規化\n"
"します。\n"
"\n"
"## 例\n"
"\n"
"    iex> ExUnit.Filters.normalize(nil, nil)\n"
"    {[], []}\n"
"\n"
"    iex> ExUnit.Filters.normalize([:foo, :bar, :bar], [:foo, :baz])\n"
"    {[:foo, :bar], [:baz]}\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.CaptureIO Summary
#: lib/ex_unit/capture_io.ex:1
msgid ""
"Functionality to capture IO for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test :example do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"テストのために、IOを捕捉する機能です。\n"
"\n"
"## 例\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test :example do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: def ExUnit.Filters.eval(include, exclude, tags, collection)
#: lib/ex_unit/filters.ex:84
msgid ""
"Evaluates the `include` and `exclude` filters against the given `tags`.\n"
"\n"
"Some filters, like `:line`, may require the whole test collection to\n"
"find the closest line, that's why it must also be passed as argument.\n"
"\n"
"Filters can either be a regular expression or any data structure\n"
"that implements to `String.Chars`, which is invoked before comparing\n"
"the filter with the tag value.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n"
"    :ok\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n"
"    {:error, :foo}\n"
"\n"
msgstr ""
"`include`と`exclude`フィルタを与えられた`tags`に対して評価します。\n"
"\n"
"いくつかの`:line`のようなフィルタは、最も近い行を見付けるために、\n"
"全てのテストを収集することを要求するかもしれません\n"
"(それが引数としても渡されなければならない理由です)。\n"
"\n"
"フィルタは正規表現あるいは、`String.Chars`(フィルタをタグと\n"
"比較するまえに起動されます)を実装した任意のデータ構造です。\n"
"\n"
"## 例\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"bar\"}, [])\n"
"    :ok\n"
"\n"
"    iex> ExUnit.Filters.eval([foo: \"bar\"], [:foo], %{foo: \"baz\"}, [])\n"
"    {:error, :foo}\n"
"\n"

#. TRANSLATORS: def ExUnit.Formatter.format_test_case_failure(test_case, arg2, counter, width, formatter)
#: lib/ex_unit/formatter.ex:119
msgid "Receives a test case and formats its failure.\n"
msgstr "テストケースを受け取り、その失敗をフォーマットします。\n"

#. TRANSLATORS: def ExUnit.Formatter.format_test_failure(test, arg2, counter, width, formatter)
#: lib/ex_unit/formatter.ex:108
msgid "Receives a test and formats its failure.\n"
msgstr "テストを受け取り、その失敗をフォーマットします。\n"

#. TRANSLATORS: def ExUnit.Formatter.format_time(run_us, load_us)
#: lib/ex_unit/formatter.ex:63
msgid ""
"Formats time taken running the test suite.\n"
"\n"
"It receives the time spent running the tests and\n"
"optionally the time spent loading the test suite.\n"
"\n"
"## Examples\n"
"\n"
"    iex> format_time(10000, nil)\n"
"    \"Finished in 0.01 seconds\"\n"
"\n"
"    iex> format_time(10000, 20000)\n"
"    \"Finished in 0.03 seconds (0.02s on load, 0.01s on tests)\"\n"
"\n"
"    iex> format_time(10000, 200000)\n"
"    \"Finished in 0.2 seconds (0.2s on load, 0.01s on tests)\"\n"
"\n"
msgstr ""
"test suiteの実行にかかった時間をフォーマットします。\n"
"\n"
"テスト実行に費した時間と、オプションでtest suite\n"
"のロードに費した時間を受け取ります。\n"
"\n"
"## 例\n"
"\n"
"    iex> format_time(10000, nil)\n"
"    \"Finished in 0.01 seconds\"\n"
"\n"
"    iex> format_time(10000, 20000)\n"
"    \"Finished in 0.03 seconds (0.02s on load, 0.01s on tests)\"\n"
"\n"
"    iex> format_time(10000, 200000)\n"
"    \"Finished in 0.2 seconds (0.2s on load, 0.01s on tests)\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Formatter.format_filters(filters, type)
#: lib/ex_unit/formatter.ex:98
msgid ""
"Formats filters used to constain cases to be run.\n"
"\n"
"## Examples\n"
"\n"
"  iex> format_filters([run: true, slow: false], :include)\n"
"  \"Including tags: [run: true, slow: false]\"\n"
"\n"
msgstr ""
"走らせるべきケースを含むフィルタをフォーマットします。\n"
"Formats filters used to constain cases to be run.\n"
"\n"
"## 例\n"
"\n"
"  iex> format_filters([run: true, slow: false], :include)\n"
"  \"Including tags: [run: true, slow: false]\"\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Callbacks.setup(var \\ {:_, [], ExUnit.Callbacks}, block)
#: lib/ex_unit/callbacks.ex:108
msgid "Defines a callback to be run before each test in a case.\n"
msgstr ""
"ケースでそれぞれのテストの前に走らせるべきコールバックを\n"
"定義します。\n"

#. TRANSLATORS: defmacro ExUnit.Callbacks.setup_all(var \\ {:_, [], ExUnit.Callbacks}, block)
#: lib/ex_unit/callbacks.ex:119
msgid "Defines a callback to be run before all tests in a case.\n"
msgstr ""
"ケースで全てのテストの前に走らせるべきコールバックを\n"
"定義します。\n"

#. TRANSLATORS: def ExUnit.Callbacks.on_exit(ref \\ :erlang.make_ref(), callback)
#: lib/ex_unit/callbacks.ex:139
msgid ""
"Defines a callback that runs on the test (or test case) exit.\n"
"\n"
"An `on_exit` callback is a function that receives no arguments and\n"
"runs in a separate process than the caller.\n"
"\n"
"`on_exit/2` is usually called from `setup` and `setup_all` callbacks,\n"
"often to undo the action performed during `setup`. However, `on_exit`\n"
"may also be called dynamically, where a reference can be used to\n"
"guarantee the callback will be invoked only once.\n"
msgstr ""
"テスト(またはテストケース)がexitする時に走らせるべき\n"
"コールバックを定義します。\n"
"\n"
"`on_exit`コールバックは、引数なしで、呼び出し側とは別の\n"
"プロセスで走る関数です。\n"
"\n"
"`on_exit/2`は、しばしば、`setup`の間に、実行されたアクションを\n"
"取り消すために、よく、`setup`や`setup_all`コールバックから呼ば\n"
"れます。\n"
"しかしながら、`on_exit`は動的にも呼ばれるかもしれません。\n"
"そこでは、リファレンスがコールバックが一度だけ起動される\n"
"ことを保証するために使われます。\n"

#. TRANSLATORS: def ExUnit.Filters.parse(filters)
#: lib/ex_unit/filters.ex:55
msgid ""
"Parses the given filters, as one would receive from the command line.\n"
"\n"
"## Examples\n"
"\n"
"    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true"
"\"])\n"
"    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n"
"\n"
msgstr ""
"コマンドラインから受け取ったフィルタをパースします。\n"
"\n"
"## 例\n"
"\n"
"    iex> ExUnit.Filters.parse([\"foo:bar\", \"baz\", \"line:9\", \"bool:true"
"\"])\n"
"    [{:foo, \"bar\"}, :baz, {:line, \"9\"}, {:bool, \"true\"}]\n"
"\n"

#. TRANSLATORS: def ExUnit.Filters.parse_path(file)
#: lib/ex_unit/filters.ex:16
msgid ""
"Parses filters out of a path.\n"
"\n"
"Determines whether a given file path (supplied to ExUnit/Mix as arguments\n"
"on the command line) includes a line number filter, and if so returns the\n"
"appropriate ExUnit configuration options.\n"
msgstr ""
"パスからフィルタを解析します。\n"
"\n"
"(コマンドライン引数としてExUnit/Mixへ供給される)与えられた\n"
"ファイルパスが行番号フィルタを含んでいるかどうかを決定します。\n"
"もしそうなら、適切なExUnitコンフィグレーションオプションを\n"
"返します。\n"

#. TRANSLATORS: Elixir.ExUnit.DocTest Summary
#: lib/ex_unit/doc_test.ex:1
msgid ""
"ExUnit.DocTest implements functionality similar to [Python's\n"
"doctest](http://docs.python.org/2/library/doctest.html).\n"
"\n"
"In a nutshell, it allows us to generate tests from the code\n"
"examples existing in a module/function/macro's documentation.\n"
"In order to do that, one needs to invoke the `doctest/1` macro\n"
"from their test case and write their examples according\n"
"to some guidelines.\n"
"\n"
"The syntax for examples is as follows. Every new test starts\n"
"on a new line, with an `iex>` prefix. Multiline expressions\n"
"can be employed if the following lines start with either\n"
"`...>` (recommended) or `iex>` prefix.\n"
"\n"
"The expected result should start at the next line after `iex>`\n"
"or `...>` line(s) and is terminated either by a newline, new\n"
"`iex>` prefix or end of the string literal.\n"
"\n"
"## Examples\n"
"\n"
"Currently, the only way to run doctests is to include them into\n"
"an ExUnit case with a `doctest` macro:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"The `doctest` macro is going to loop through all functions and\n"
"macros defined in `MyModule`, parsing their documentation in\n"
"search of code examples.\n"
"\n"
"A very basic example is:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"Expressions on multiple lines are also supported:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2,4,6]\n"
"\n"
"Multiple results can be checked within the same test:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"If you want to keep any two tests separate,\n"
"add an empty line between them:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"function a/0 undefined\" error\n"
"    2\n"
"\n"
"Similarly to iex you can use numbers in your \"prompts\":\n"
"\n"
"    iex(1)> [1+2,\n"
"    ...(1)>  3]\n"
"    [3,3]\n"
"\n"
"This is useful in two use cases:\n"
"\n"
"  * being able to refer to specific numbered scenarios\n"
"  * copy-pasting examples from an actual iex session\n"
"\n"
"We also allow you to select or skip some functions when calling\n"
"`doctest`. See the documentation for more info.\n"
"\n"
"## Opaque types\n"
"\n"
"Some types internal structure are kept hidden and instead show a\n"
"user-friendly structure when inspecting the value. The idiom in\n"
"Elixir is to print those data types as `#Name<...>`. Doctest will\n"
"test these values by doing a string compare.\n"
"\n"
"    iex> Enum.into([a: 10, b: 20], HashDict.new)\n"
"    #HashDict<[b: 20, a: 10]>\n"
"\n"
"The above example will be tested with the following match:\n"
"`\"#HashDict<[b: 20, a: 10]>\" = inspect(Enum.into([a: 10, b: 20], HashDict."
"new))`.\n"
"\n"
"## Exceptions\n"
"\n"
"You can also showcase expressions raising an exception, for example:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"What DocTest will be looking for is a line starting with `** (` and it\n"
"will parse it accordingly to extract the exception name and message.\n"
"At this moment, the exception parser would make the parser treat the next\n"
"line as a start of a completely new expression (if it is prefixed with "
"`iex>`)\n"
"or a no-op line with documentation. Thus, multiline messages are not\n"
"supported.\n"
"\n"
"## When not to use doctest\n"
"\n"
"In general, doctests are not recommended when your code examples contain\n"
"side effects. For example, if a doctest prints to standard output, doctest\n"
"will not try to capture the output.\n"
"\n"
"Similarly, doctests do not run in any kind of sandbox. So any module\n"
"defined in a code example is going to linger throughout the whole test\n"
"suite run.\n"
msgstr ""
"ExUnit.DocTestは、[Python's\n"
"doctest](http://docs.python.org/2/library/doctest.html)と\n"
"にた機能を実装しています。\n"
"\n"
"簡単に言えば、module/function/macroのドキュメントに存在し\n"
"ているコード例から、テストを生成することを許します。\n"
"そうするために、それらのテストケースから`doctest/1`マクロを\n"
"起動する必要と、いくつかのガイドラインに従って、例を\n"
"書く必要があります。\n"
"\n"
"例の構文は下のとおりです。新しいテスト毎に、`iex>`\n"
"プレフィックスで新しい行を始めます。\n"
"後続行が`...>`(推奨)か`iex>`プレフィックスから始まる\n"
"なら、複数行の式が使用できます。\n"
"\n"
"期待される結果は`iex>`か`...>`行の次の行から開始されるべきで、\n"
"それぞれの行は改行され、新しい`iex`プレフィックスか文字列\n"
"リテラルの終了により終了されるべきです。\n"
"\n"
"## 例\n"
"\n"
"現在、doctestを走らせる唯１つの方法は、ExUnitケース中に\n"
"`doctest`マクロを含めることです:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"`doctest`マクロは、コード例を探してドキュメントをパースしながら、\n"
"`MyModule`で定義された全ての関数とマクロでループするでしょう。\n"
"\n"
"非常に着本的な例は:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"複数行の式もサポートされています:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2,4,6]\n"
"\n"
"同じテストの中で、複数の結果もチェックさせることができます:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"任意の二つのテストを分離したいなら、\n"
"間に空行を追加してください:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"function a/0 undefined\" error\n"
"    2\n"
"\n"
"iexと同様に、\"プロンプト\"に番号を使うことができます:\n"
"\n"
"    iex(1)> [1+2,\n"
"    ...(1)>  3]\n"
"    [3,3]\n"
"\n"
"これは二つのケースで便利です:\n"
"\n"
"  * 特定の番号付けられたシナリオを参照することができること\n"
"  * 実際のiexセッションからの例のコピーペーストができること\n"
"\n"
"`doctest`を呼ぶとき、関数を選択したりスキップしたりすることも\n"
"出来ます。詳細はドキュメントを参照してください。\n"
"\n"
"## Opaque types\n"
"\n"
"いくつかの内部構造のタイプは隠されたままで、代わりに、\n"
"値をインスペクトするときのユーザフレンドリな構造が、\n"
"表示されます。Elixirのイディオムは、`#Name<...>`として\n"
"それらのデータタイプを表示することです。doctestは、\n"
"文字列比較をすることで、これらの値をテストします。\n"
"\n"
"    iex> Enum.into([a: 10, b: 20], HashDict.new)\n"
"    #HashDict<[b: 20, a: 10]>\n"
"\n"
"上の例は、以下のマッチでテストされます:\n"
"`\"#HashDict<[b: 20, a: 10]>\" = inspect(Enum.into([a: 10, b: 20], HashDict."
"new))`.\n"
"\n"
"## Exceptions\n"
"\n"
"例外を上げる式を紹介することもできます。例えば:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"DocTestは、`**(`で始まる行を探し、それをパースし、それによって\n"
"例外名とメッセージを抽出します。\n"
"現在、例外パーサは、パーサを(`iex>`プレフィックス\n"
"なら)完全に新しい式の開始か、ドキュメンとのno-opの行として\n"
"次の行を扱います。\n"
"従って、複数行のメッセージはサポートされていません。\n"
"\n"
"## When not to use doctest\n"
"\n"
"一般に、doctestは副作用を含むコード例では推奨されません。\n"
"例えば、doctestが標準出力へプリントするなら、doctestは\n"
"出力を捕捉しようとしません。\n"
"\n"
"同様に、doctestは如何なる種類のサンドボックスでも走りません。\n"
"だから、コード例で定義された任意のモジュールは、テストスイート\n"
"が走る間じゅう、残ります。\n"

#. TRANSLATORS: Elixir.ExUnit.Callbacks Summary
#: lib/ex_unit/callbacks.ex:1
msgid ""
"Defines ExUnit Callbacks.\n"
"\n"
"This module defines both `setup_all` and `setup` callbacks, as well as\n"
"the `on_exit` facility.\n"
"\n"
"The setup callbacks are defined via macros and each one can optionally\n"
"receive a map with metadata, usually referred to as `context`. The\n"
"callback may optionally put extra data into `context` to be used in\n"
"the tests.\n"
"\n"
"The `setup_all` callbacks are invoked once before the first test's `setup`\n"
"and all `setup` callbacks are run before each test. No callback runs if the\n"
"test case has no tests or all tests were filtered out.\n"
"\n"
"`on_exit` callbacks are registered on demand, usually to undo an action\n"
"performed by a setup callback. `on_exit` may also take a reference,\n"
"allowing callback to be overridden in the future. A registered `on_exit`\n"
"callback always runs, while failures in `setup` and `setup_all` will stop\n"
"all remaining setup callbacks from executing.\n"
"\n"
"Finally, `setup_all` callbacks run in the test case process, while all\n"
"`setup` callbacks run in the same process as the test itself. `on_exit`\n"
"callbacks always run in a separate process than the test case or the\n"
"test itself. Since the test process exits with reason `:shutdown`, most\n"
"of times `on_exit/1` can be avoided as processes are going to clean\n"
"up on their own.\n"
"\n"
"## Context\n"
"\n"
"If you return `{:ok, <dict>}` from `setup_all`, the dictionary\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup_all`, `setup` and the test itself.\n"
"\n"
"Similarly, returning `{:ok, <dict>}` from `setup`, the dict returned\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup` and the `test` itself.\n"
"\n"
"Returning `:ok` leaves the context unchanged in both cases.\n"
"\n"
"Returning anything else from `setup_all` will force all tests to fail,\n"
"while a bad response from `setup` causes the current test to fail.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # `setup_all` is called once before every test\n"
"      setup_all do\n"
"        IO.puts \"Starting AssertionTest\"\n"
"\n"
"        # No metadata\n"
"        :ok\n"
"      end\n"
"\n"
"      # `setup` is called before each test is run\n"
"      setup do\n"
"        IO.puts \"This is a setup callback\"\n"
"\n"
"        on_exit fn ->\n"
"          IO.puts \"This is invoked once the test is done\"\n"
"        end\n"
"\n"
"        # Returns extra metadata, it must be a dict\n"
"        {:ok, hello: \"world\"}\n"
"      end\n"
"\n"
"      # Same as `setup`, but receives the context\n"
"      # for the current test\n"
"      setup context do\n"
"        IO.puts \"Setting up: #{context[:test]}\"\n"
"        :ok\n"
"      end\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"\n"
"      test \"another one\", context do\n"
"        assert context[:hello] == \"world\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"ExUnitコールバックを定義します。\n"
"\n"
"このモジュールは`setup_all`と`setup`コールバックの両方を定義します\n"
"(`on_exit`機能だけでなく)。\n"
"\n"
"setupコールバックはマクロとして定義され、それぞれは、\n"
"通常`context`として参照される、\n"
"メタデータのマップを、オプションで受け取ることができます。\n"
"コールバックは、オプションで、\n"
"テストで使われる追加のデータを、`context`に入れるかもしれません。\n"
"\n"
"`setup_all`コールバックは最初のテストの`setup`の前に一度だけ\n"
"起動され、それぞれのテストの前に、全ての`setup`コールバックは\n"
"走ります。テストケースがテストを持っていない、あるいは、\n"
"全てのテストがフィルタで除外されたなら、コールバックは\n"
"走りません。\n"
"\n"
"`on_exit`コールバックは、\n"
"通常、setupコールバックにより実行されたアクションを\n"
"元にもどすために、必要に応じて登録されます。\n"
"`on_exit`は、\n"
"リファレンスを取り、将来コールバックを\n"
"オーバライドすることを許すかもしれません。\n"
"`setup`と`setup_all`の失敗が、\n"
"実行中から全ての残ったsetupコールバックを停止する間、\n"
"登録された`on_exit`が常に走ります。\n"
"\n"
"最後に、`setup_all`コールバックはテストケースプロセスの中で\n"
"走り、テストそれ自身と同じプロセスで全ての`setup`コールバックは\n"
"走ります。\n"
"`on_exit`コールバックは常にテーストケースあるいは、テスト自身とは、\n"
"別のプロセスで走ります。\n"
"reason `:shutdown`でテストプロセスがexitしたとき、\n"
"殆どの場合、\n"
"プロセスがそれ自身でクリーンアプをするので、`on_exit/1`は避ける\n"
"ことができます。\n"
"\n"
"## Context\n"
"\n"
"もし`setup_all`から`{:ok, <dict>}`を返したら、\n"
"その辞書は、現在のコンテキストにマージされ、以降の全ての\n"
"`setup_all`、`setup`と、test自身で有効になります。\n"
"\n"
"同様に、`setup`から`{:ok, <dict>}`を返したら、その\n"
"返されたdictは現在のコンテキストにマージされ、以降の全ての\n"
"`setup`と`test`自身で有効になります。\n"
"\n"
"`:ok`を返すことは、両方のケースでコンテキストを変更しない\n"
"ままにします。\n"
"\n"
"`setup_all`から、それ以外を返すと、全てのテストを強制的に\n"
"失敗にし、`setup`からの悪い応答は、現在のテストを失敗を\n"
"もたらします。\n"
"\n"
"## 例\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # `setup_all` is called once before every test\n"
"      setup_all do\n"
"        IO.puts \"Starting AssertionTest\"\n"
"\n"
"        # No metadata\n"
"        :ok\n"
"      end\n"
"\n"
"      # `setup` is called before each test is run\n"
"      setup do\n"
"        IO.puts \"This is a setup callback\"\n"
"\n"
"        on_exit fn ->\n"
"          IO.puts \"This is invoked once the test is done\"\n"
"        end\n"
"\n"
"        # Returns extra metadata, it must be a dict\n"
"        {:ok, hello: \"world\"}\n"
"      end\n"
"\n"
"      # Same as `setup`, but receives the context\n"
"      # for the current test\n"
"      setup context do\n"
"        IO.puts \"Setting up: #{context[:test]}\"\n"
"        :ok\n"
"      end\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"\n"
"      test \"another one\", context do\n"
"        assert context[:hello] == \"world\"\n"
"      end\n"
"    end\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit Summary
#: lib/ex_unit.ex:1
msgid ""
"Basic unit testing framework for Elixir.\n"
"\n"
"## Example\n"
"\n"
"A basic setup for ExUnit is shown below:\n"
"\n"
"    # File: assertion_test.exs\n"
"\n"
"    # 1) Start ExUnit.\n"
"    ExUnit.start\n"
"\n"
"    # 2) Create a new test module (test case) and use `ExUnit.Case`.\n"
"    defmodule AssertionTest do\n"
"      # 3) Notice we pass `async: true`, this runs the test case\n"
"      #    concurrently with other test cases\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # 4) Use the `test` macro instead of `def` for clarity.\n"
"      test \"the truth\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"To run the tests above, run the file\n"
"using `elixir` from the command line. Assuming you named the file\n"
"`assertion_test.exs`, you can run it as:\n"
"\n"
"    bin/elixir assertion_test.exs\n"
"\n"
"## Case, Callbacks and Assertions\n"
"\n"
"See `ExUnit.Case` and `ExUnit.Callbacks`\n"
"for more information about defining test cases.\n"
"\n"
"The `ExUnit.Assertions` module contains\n"
"a set of macros to easily generate assertions with appropriate\n"
"error messages.\n"
"\n"
"## Integration with Mix\n"
"\n"
"Mix is the project management and build tool for Elixir. Invoking `mix "
"test`\n"
"from the command line will run the tests in each file matching the pattern\n"
"`*_test.exs` found in the `test` directory of your project.\n"
"\n"
"You must create a `test_helper.exs` file inside the\n"
"`test` directory and put the code common to all tests there.\n"
"\n"
"The minimum example of a `test_helper.exs` file would be:\n"
"\n"
"    # test/test_helper.exs\n"
"    ExUnit.start\n"
"\n"
"Mix will load the `test_helper.exs` file before executing the tests.\n"
"It is not necessary to `require` the `test_helper.exs` file in your test\n"
"files. See `Mix.Tasks.Test` for more information.\n"
msgstr ""
"基本的なElixirのためのユニットテストフレームワークです。\n"
"\n"
"## 例\n"
"\n"
"基本的なExUnitのsetupは以下の通りです:\n"
"\n"
"    # File: assertion_test.exs\n"
"\n"
"    # 1) Start ExUnit.\n"
"    ExUnit.start\n"
"\n"
"    # 2) Create a new test module (test case) and use `ExUnit.Case`.\n"
"    defmodule AssertionTest do\n"
"      # 3) Notice we pass `async: true`, this runs the test case\n"
"      #    concurrently with other test cases\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # 4) Use the `test` macro instead of `def` for clarity.\n"
"      test \"the truth\" do\n"
"        assert true\n"
"      end\n"
"    end\n"
"\n"
"上のテストを走らせるため、コマンドラインからelixirを使い、\n"
"ファイルを走らせます。ファイルに`assertion_test.exs`と名付\n"
"けたとすると、以下のように走らせることができます:\n"
"\n"
"    bin/elixir assertion_test.exs\n"
"\n"
"## Case, Callbacks and Assertions\n"
"\n"
"テストケースを定義することについての詳細は、\n"
"`ExUnit.Case`と`ExUnit.Callbacks`を参照してください。\n"
"\n"
"`ExUnit.Assertions`モジュールは、適切なエラーメッセージと\n"
"ともにアサーションを簡単に生成するための、一組のマクロを\n"
"含みます。\n"
"\n"
"## Integration with Mix\n"
"\n"
"MixはElixirのためのプロジェクトマネジメントとビルドツールです。\n"
"コマンドラインから`mix test`を起動すると、\n"
"あなたのプロジェクトの`test`ディレクトリの`*_test.exs`パターンに\n"
"マッチするファイルを見付けて、それぞれの中のテストを走らせます。\n"
"\n"
"あなたは`test`ディレクトリに`test_helper.exs`ファイルを\n"
"作らなければなりません。そして、全てのテストに\n"
"共通のコードをここに書かなければなりません。\n"
"\n"
"`test_helper.exs`ファイルの最小限の例は:\n"
"\n"
"    # test/test_helper.exs\n"
"    ExUnit.start\n"
"\n"
"Mixはテストを実行する前に`test_helper.exs`ファイルをロードします。\n"
"testファイルに`test_helper.exs`の`require`は必要ありません。\n"
"詳細は`Mix.Tasks.Test`を参照してください。\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:358
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
"`function`実行中に`exception`が上ると表明します。\n"
"レスキューされた例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:332
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the `expected_message`. Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"
msgstr ""
"`function`実行中に`excepted_message`が上ると表明します。\n"
"レスキューされた例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:389
msgid ""
"Asserts that `val1` and `val2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
"`val1`と`val2`の差が`delta`より小さいと表明します。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:66
msgid ""
"Asserts its argument is true.\n"
"\n"
"`assert` tries to be smart and provide good\n"
"reporting whenever there is a failure. In particular, if\n"
"given a match expression, it will report any failure in terms\n"
"of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"If the expression is a comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
msgstr ""
"引数がtrueであると表明します。\n"
"\n"
"`assert`は、失敗があるときは何時でも\n"
"スマートでよい報告を提供しようとします。\n"
"特に、マッチ式が与えられたなら、その\n"
"マッチに関してどんな失敗もレポートします。\n"
"以下が与えられたとして\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"以下をみることになります:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"もし式が比較演算子なら、メッセージが\n"
"式の両側の値を表示します。以下のアサーションは、\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
"以下のメッセージを伴って失敗するでしょう:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(expected, message \\ nil)
#: lib/ex_unit/assertions.ex:270
msgid ""
"Asserts a message was received and is in the current process' mailbox.\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
"メッセージが受信され、現在のプロセスのmailboxに\n"
"あると表明します。\n"
"タイムアウトを0にセットすると、待ちません。\n"
"\n"
"`expected`引数はパターンです。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:249
msgid ""
"Asserts a message was or is going to be received. Unlike\n"
"`assert_received`, it has a default timeout of 100 milliseconds.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
"メッセージが受信されたか、受信されようとしていると表明\n"
"します。`assert_received`と違って、\n"
"100ミリ秒のデフォルトタイムアウトを持ちます。\n"
"\n"
"`expected`引数はパターンです。\n"
"\n"
"## 例\n"
"\n"
"    assert_receive :hello\n"
"\n"
"大きなタイムアウトに対して表明します:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"

#. TRANSLATORS: def ExUnit.CaptureIO.capture_io(fun)
#: lib/ex_unit/capture_io.ex:62
msgid ""
"Captures IO generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"By default, `capture_io` replaces the `group_leader` (`:stdio`)\n"
"for the current process. However, the capturing of any other\n"
"named device, such as `:stderr`, is also possible globally by\n"
"giving the registered device name explicitly as an argument.\n"
"\n"
"Note that when capturing something other than `:stdio`,\n"
"the test should run with async false.\n"
"\n"
"When capturing `:stdio`, if the `:capture_prompt` option is `false`,\n"
"prompts (specified as arguments to `IO.get*` functions) are not\n"
"captured.\n"
"\n"
"A developer can set a string as an input. The default\n"
"input is `:eof`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john"
"\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn -"
">\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"
msgstr ""
"`fun`を評価中に生成されたIOを捕捉します。\n"
"\n"
"捕捉された出力のバイナリを返します。\n"
"\n"
"デフォルトで、`capture_io`は現在のプロセスの\n"
"`group_leader`(`:stdio`)を置き換えます。しかしながら、\n"
"グローバルな明示的に登録されたデバイス名を引数として\n"
"渡すことができる、`:stderr`のような、\n"
"他の任意の名前のデバイスの捕捉もまた、可能です。\n"
"\n"
"`:stdio`以外を捕捉するとき、テストは、asyncをfalseにして\n"
"走らせないといけないことに、気を付けてください。\n"
"\n"
"`:stdio`を捕捉するとき、`:capture_prompt`オプションが\n"
"`false`なら、(`IO.get*`関数への引数として\n"
"指定された)プロンプトは、捕捉されません。\n"
"\n"
"開発者は、入力として文字列をセットできます。\n"
"デフォルト入力は`:eof`です。\n"
"\n"
"## 例\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john"
"\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn -"
">\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(not_expected, message \\ nil)
#: lib/ex_unit/assertions.ex:495
msgid ""
"Asserts a message was not received (i.e. it is not in the current process "
"mailbox).\n"
"The `not_expected` argument must be a match pattern.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"
msgstr ""
"メッセージが受信されていないと表明します(即ち、\n"
"現在のプロセスのmailboxにはないということです)。\n"
"`not_expected`引数はマッチパターンでなければなりません。\n"
"\n"
"タイムアウトに0をセットすると、待ちません。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert(value, left, right, message)
#: lib/ex_unit/assertions.ex:223
msgid ""
"Asserts `value` is true.\n"
"If it fails, it raises an expectation error\n"
"using the given `left` and `right` values.\n"
"\n"
"You probably don't need to use this—the regular `assert` function\n"
"handles this for you.\n"
"\n"
"## Examples\n"
"\n"
"    assert this > that, this, that, \"more than\"\n"
"\n"
msgstr ""
"`value`がtrueと表明します。\n"
"もし失敗すると、与えられた`left`と`right`の値を使って\n"
"エラー例外を上げます。\n"
"\n"
"たぶん、これをそのように扱う「この標準の」`assert`関数を\n"
"使う必要はないでしょう。\n"
"\n"
"## 例\n"
"\n"
"    assert this > that, this, that, \"more than\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:201
msgid ""
"Asserts `value` is true, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
"`value`がtrueと表明し、さもなければ与えられた`message`を\n"
"表示します。\n"
"\n"
"## 例\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:458
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
"`value`が`nil`か`false`である(つまり、`value`は真ではない)という表明です。\n"
"\n"
"## 例\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:537
msgid ""
"Asserts `val1` and `val2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
"`val1`と`val2`が`delta`の間にないという表明です。\n"
"\n"
"もし`message`があれば、値についての情報は、自動的に\n"
"それに追加されます。\n"
"\n"
"## 例\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:406
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
"`expression`が値をthrowするという表明です。\n"
"throwされた値を返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:419
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
"`expression`がexitするという表明です。\n"
"exit status/メッセージを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:432
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
"`expression`がerrorを引き起すという表明です。\n"
"errorを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"

#. TRANSLATORS: def ExUnit.run()
#: lib/ex_unit.ex:212
msgid ""
"API used to run the tests. It is invoked automatically\n"
"if ExUnit is started via `ExUnit.start/1`.\n"
"\n"
"Returns a map containing the total number of tests, the number\n"
"of failures and the number of skipped tests.\n"
msgstr ""
"テストを走らせるために使われるAPIです。ExUnitが\n"
"`ExUnit.start/1`により開始すると、自動的に起動されます。\n"
"\n"
"テストの数と、失敗の数とスキップしたテストの数を\n"
"含むマップを返します。\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(not_expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:479
msgid ""
"    refute_receive message, timeout \\ 100, message \\ nil\n"
"\n"
"Asserts `message` was not received (and won't be received) within\n"
"the `timeout` period.\n"
"\n"
"The `not_expected` argument is a match pattern.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with a explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
"    refute_receive message, timeout \\ 100, message \\ nil\n"
"\n"
"`message`が`timeout`の間に受信されなかった(そして\n"
"受信されないだろう)という表明です。\n"
"\n"
"`not_expected`引数はマッチパターンです。\n"
"\n"
"## 例\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with a explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Case.test(message, var \\ {:_, [], ExUnit.Case}, contents)
#: lib/ex_unit/case.ex:202
msgid ""
"Define a test with a string.\n"
"\n"
"Provides a convenient macro that allows a test to be\n"
"defined with a string. This macro automatically inserts\n"
"the atom `:ok` as the last line of the test. That said,\n"
"a passing test always returns `:ok`, but, more importantly,\n"
"it forces Elixir to not tail call optimize the test and\n"
"therefore avoids hiding lines from the backtrace.\n"
"\n"
"## Examples\n"
"\n"
"    test \"true is equal to true\" do\n"
"      assert true == true\n"
"    end\n"
"\n"
msgstr ""
"文字列でテストを定義します。\n"
"\n"
"文字列でテストを定義することを許す便利なマクロを提供\n"
"します。このマクロは、テストの最後の行として、\n"
"アトム`:ok`を自動的に挿入します。それは、\n"
"テストは常に`:ok`を返すということですが、もっと重要な\n"
"ことは、Elixirに、末尾再帰最適化をさせないように強制\n"
"し、バックトレースから行番号を隱すことを避けます。\n"
"\n"
"## 例\n"
"\n"
"    test \"true is equal to true\" do\n"
"      assert true == true\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.CaseTemplate.using(var \\ {:_, [], ExUnit.CaseTemplate}, list2)
#: lib/ex_unit/case_template.ex:66
msgid ""
"Allows a developer to customize the using block\n"
"when the case template is used.\n"
msgstr ""
"開発者に、case templateが使われるとき、ブロックを\n"
"使ってカスタマイズを許します。\n"

#. TRANSLATORS: Elixir.ExUnit.Filters Summary
#: lib/ex_unit/filters.ex:1
msgid "Conveniences for parsing and evaluating filters.\n"
msgstr "フィルタをパースし評価するのに便利なものです。\n"

#. TRANSLATORS: Elixir.ExUnit.Test Summary
#: lib/ex_unit.ex:64
msgid ""
"A struct that keeps information about the test.\n"
"\n"
"It is received by formatters and contains the following fields:\n"
"\n"
"  * `:name`  - the test name\n"
"  * `:case`  - the test case\n"
"  * `:state` - the test state (see ExUnit.state)\n"
"  * `:time`  - the time to run the test\n"
"  * `:tags`  - the test tags\n"
"\n"
msgstr ""
"テストについての情報を保持する構造体です。\n"
"\n"
"それはフォーマッタにより受信され、以下のフィールドを含みます:\n"
"\n"
"  * `:name`  - テスト名\n"
"  * `:case`  - テストケース\n"
"  * `:state` - テストステート (see ExUnit.state)\n"
"  * `:time`  - テスト実行時刻\n"
"  * `:tags`  - テストのタグ\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.TestCase Summary
#: lib/ex_unit.ex:91
msgid ""
"A struct that keeps information about the test case.\n"
"\n"
"It is received by formatters and contains the following fields:\n"
"\n"
"  * `:name`  - the test case name\n"
"  * `:state` - the test state (see ExUnit.state)\n"
"  * `:tests` - all tests for this case\n"
"\n"
msgstr ""
"テストケースについての情報を保持する構造体です。\n"
"\n"
"フォーマッタにより受信され、以下のフィールドを含みます:\n"
"\n"
"  * `:name`  - テストケース名\n"
"  * `:state` - テストステート (see ExUnit.state)\n"
"  * `:tests` - このケースの全てのテスト\n"
"\n"
