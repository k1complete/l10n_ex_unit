#. TRANSLATORS: Elixir.ExUnit.CaptureIO Summary
#: lib/ex_unit/capture_io.ex:1 
msgid ""
"Functionality to capture IO for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureIO\n"
"\n"
"      test :example do\n"
"        assert capture_io(fn ->\n"
"          IO.puts \"a\"\n"
"        end) == \"a\\n\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.CaptureIO.capture_io(fun)
#: lib/ex_unit/capture_io.ex:62 
msgid ""
"Captures IO generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"By default, `capture_io` replaces the `group_leader` (`:stdio`)\n"
"for the current process. However, the capturing of any other\n"
"named device, such as `:stderr`, is also possible globally by\n"
"giving the registered device name explicitly as an argument.\n"
"\n"
"Note that when capturing something other than `:stdio`,\n"
"the test should run with async false.\n"
"\n"
"When capturing `:stdio`, if the `:capture_prompt` option is `false`,\n"
"prompts (specified as arguments to `IO.get*` functions) are not\n"
"captured.\n"
"\n"
"A developer can set a string as an input. The default\n"
"input is `:eof`.\n"
"\n"
"## Examples\n"
"\n"
"    iex> capture_io(fn -> IO.write \"john\" end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(:stderr, fn -> IO.write(:stderr, \"john\") end) == \"john\"\n"
"    true\n"
"\n"
"    iex> capture_io(\"this is input\", fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \">this is input\"\n"
"    true\n"
"\n"
"    iex> capture_io([input: \"this is input\", capture_prompt: false], fn ->\n"
"    ...>   input = IO.gets \">\"\n"
"    ...>   IO.write input\n"
"    ...> end) == \"this is input\"\n"
"    true\n"
"\n"
msgstr ""
