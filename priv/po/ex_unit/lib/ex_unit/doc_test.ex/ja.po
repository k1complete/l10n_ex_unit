msgid ""
msgstr ""
"Project-Id-Version: l 10n_ex_unit\n"
"PO-Revision-Date: 2015-12-27 15:48+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro ExUnit.DocTest.doctest(mod, opts \\ [])
#: lib/ex_unit/doc_test.ex:162
msgid ""
"This macro is used to generate ExUnit test cases for doctests.\n"
"\n"
"Calling `doctest(Module)` will generate tests for all doctests found\n"
"in the module `Module`\n"
"\n"
"Options can also be given:\n"
"\n"
"  * `:except` - generate tests for all functions except those listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:only`   - generate tests only for functions listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:import` - when `true`, one can test a function defined in the module\n"
"    without referring to the module name. However, this is not feasible "
"when\n"
"    there is a clash with a module like Kernel. In these cases, `import`\n"
"    should be set to `false` and a full `M.f` construct should be used.\n"
"\n"
"## Examples\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"This macro is auto-imported with every `ExUnit.Case`.\n"
msgstr ""
"このマクロはdoctestのためのExUnitテストケースを生成するために\n"
"使われます。\n"
"\n"
"`doctest(Module)`を呼ぶと、モジュール`Module`に見付かった、\n"
"全てのdoctestのためのテストを生成します。\n"
"\n"
"以下のオプションも提供されます:\n"
"\n"
"  * `:except` - リストされた関数を除外してテストを生成します\n"
"    (`{function, arity}`タプルと/または:moduledocのリストです)。\n"
"\n"
"  * `:only` - リストされた関数のみのテストを生成します\n"
"    (`{function, arity}`タプルと/または:moduledocのリストです)。\n"
"\n"
"  * `:import` - `true`のとき、モジュール名を参照することなく、\n"
"    モジュールで定義された関数をテストすることができます。し\n"
"    かしながら、Kernelのようなモジュールとの衝突があるとき、\n"
"    これは可能ではありません。このような場合、`import`は\n"
"    `false`にセットし、完全な`M.f`文法が使われなければなりま\n"
"    せん。\n"
"\n"
"## 例\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"このマクロは、`ExUnit.Case`毎に自動的にインポートされます。\n"

#. TRANSLATORS: Elixir.ExUnit.DocTest Summary
#: lib/ex_unit/doc_test.ex:2
msgid ""
"ExUnit.DocTest implements functionality similar to [Python's\n"
"doctest](https://docs.python.org/2/library/doctest.html).\n"
"\n"
"In a nutshell, it allows us to generate tests from the code\n"
"examples existing in a module/function/macro's documentation.\n"
"In order to do that, one needs to invoke the `doctest/1` macro\n"
"from their test case and write their examples according\n"
"to some guidelines.\n"
"\n"
"The syntax for examples is as follows. Every new test starts\n"
"on a new line, with an `iex>` prefix. Multiline expressions\n"
"can be employed if the following lines start with either\n"
"`...>` (recommended) or `iex>` prefix.\n"
"\n"
"The expected result should start at the next line after `iex>`\n"
"or `...>` line(s) and is terminated either by a newline, new\n"
"`iex>` prefix or end of the string literal.\n"
"\n"
"## Examples\n"
"\n"
"Currently, the only way to run doctests is to include them into\n"
"an ExUnit case with a `doctest` macro:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"The `doctest` macro is going to loop through all functions and\n"
"macros defined in `MyModule`, parsing their documentation in\n"
"search of code examples.\n"
"\n"
"A very basic example is:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"Expressions on multiple lines are also supported:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"Multiple results can be checked within the same test:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"If you want to keep any two tests separate,\n"
"add an empty line between them:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"undefined function a/0\" error\n"
"    2\n"
"\n"
"If you don't want to assert for every result in a doctest, you can just "
"omit\n"
"the result:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\n"
"    iex> is_pid(pid)\n"
"    true\n"
"\n"
"This is useful when the result is something variable (like a pid in the\n"
"example above) or when the result is a complicated data structure and you\n"
"don't want to show it all, but just parts of it or some of its properties.\n"
"\n"
"Similarly to IEx you can use numbers in your \"prompts\":\n"
"\n"
"    iex(1)> [1 + 2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"This is useful in two use cases:\n"
"\n"
"  * being able to refer to specific numbered scenarios\n"
"  * copy-pasting examples from an actual IEx session\n"
"\n"
"We also allow you to select or skip some functions when calling\n"
"`doctest`. See the documentation for more info.\n"
"\n"
"## Opaque types\n"
"\n"
"Some types internal structure are kept hidden and instead show a\n"
"user-friendly structure when inspecting the value. The idiom in\n"
"Elixir is to print those data types as `#Name<...>`. Because those\n"
"values are treated as comments in Elixir code due to the leading\n"
"`#` sign, they require special care when used in doctests.\n"
"\n"
"Imagine you have a map with a MapSet inside which is printed as:\n"
"\n"
"    %{users: #MapSet<[:foo, :bar]>}\n"
"\n"
"If you try to match on such expression, `doctest` will fail to compile.\n"
"You have two options to solve this.\n"
"\n"
"The first one is to rely on the fact that doctest can compare internal\n"
"structures as long as they are at the root. So one could write:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    iex> map.users\n"
"    #MapSet<[:foo, :bar]>\n"
"\n"
"Whenever a doctest starts with \"#Name<\", `doctest` will perform a string\n"
"comparison. For example, the above test will perform the following match:\n"
"\n"
"    inspect(map.users) == \"#MapSet<[:foo, :bar]>\"\n"
"\n"
"Alternatively, since doctest results are actually evaluated, you can have\n"
"the MapSet building expression as the doctest result:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"\n"
"The downside of this approach is that the doctest result is not really\n"
"what users would see in the terminal.\n"
"\n"
"## Exceptions\n"
"\n"
"You can also showcase expressions raising an exception, for example:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"What DocTest will be looking for is a line starting with `** (` and it\n"
"will parse it accordingly to extract the exception name and message.\n"
"At this moment, the exception parser would make the parser treat the next\n"
"line as a start of a completely new expression (if it is prefixed with "
"`iex>`)\n"
"or a no-op line with documentation. Thus, multiline messages are not\n"
"supported.\n"
"\n"
"## When not to use doctest\n"
"\n"
"In general, doctests are not recommended when your code examples contain\n"
"side effects. For example, if a doctest prints to standard output, doctest\n"
"will not try to capture the output.\n"
"\n"
"Similarly, doctests do not run in any kind of sandbox. So any module\n"
"defined in a code example is going to linger throughout the whole test\n"
"suite run.\n"
msgstr ""
"ExUnit.DocTestは、[Python's\n"
"doctest](http://docs.python.org/2/library/doctest.html)と似た\n"
"機能を実装しています。\n"
"\n"
"簡単に言えば、module/function/macroのドキュメントに存在してい\n"
"るコード例から、テストを生成することを許します。そうするため\n"
"に、それらのテストケースから`doctest/1`マクロを起動する必要と、\n"
"いくつかのガイドラインに従って、例を書く必要があります。\n"
"\n"
"例の構文は下のとおりです。新しいテスト毎に、`iex>`プレフィッ\n"
"クスで新しい行を始めます。後続行が`...>`(推奨)か`iex>`プレ\n"
"フィックスから始まるなら、複数行の式が使用できます。\n"
"\n"
"期待される結果は`iex>`か`...>`行の次の行から開始されるべきで、\n"
"それぞれの行は改行され、新しい`iex`プレフィックスか文字列\n"
"リテラルの終了により終了されるべきです。\n"
"\n"
"## 例\n"
"\n"
"現在、doctestを走らせる唯１つの方法は、ExUnitケース中に\n"
"`doctest`マクロを含めることです:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"`doctest`マクロは、コード例を探してドキュメントをパースしなが\n"
"ら、`MyModule`で定義された全ての関数とマクロでループするでしょ\n"
"う。\n"
"\n"
"非常に着本的な例は:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"複数行の式もサポートされています:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"同じテストの中で、複数の結果もチェックさせることができます:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"任意の二つのテストを分離したいなら、\n"
"間に空行を追加してください:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"function a/0 undefined\" error\n"
"    2\n"
"\n"
"もし一々doctestの結果assertしたくないなら、結果を省略できます:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\\n\"\n"
"    iex> is_pid(pid)\\n\"\n"
"    true\\n\"\n"
"\n"
"これは結果が何かの変数(上の例ではpidのような)や、結果が難しい\n"
"データ構造の時、そして、全てを表示したくはないが、その一部や\n"
"いくつかのプロパティを表示したい場合に便利です。\n"
"\n"
"IExと同様に、\"プロンプト\"に番号を使うことができます:\n"
"\n"
"    iex(1)> [1+2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"これは二つのケースで便利です:\n"
"\n"
"  * 特定の番号付けられたシナリオを参照することができること\n"
"  * 実際のiexセッションからの例のコピーペーストができること\n"
"\n"
"`doctest`を呼ぶとき、関数を選択したりスキップしたりすることも\n"
"出来ます。詳細はドキュメントを参照してください。\n"
"\n"
"## Opaque types\n"
"\n"
"いくつかの内部構造のタイプは隠されたままで、代わりに、値をイ\n"
"ンスペクトするときのユーザフレンドリな構造が、表示されます。\n"
"Elixirのイディオムは、`#Name<...>`としてそれらのデータタイプ\n"
"を表示することです。これらの`#`記号で始まる値はElixirコードで\n"
"はコメントとして扱われるので、doctestでは使われるとき、特別な\n"
"注意を要求します。\n"
"\n"
"内部にMapSetを持つマップを持っていてそれを表示したとします:\n"
"\n"
"    %{users: #MapSet<[:foo, :bar]>}\n"
"\n"
"もしそのような式にマッチしようとしたなら、`doctest`はコンパイルに\n"
"失敗します。これを解決するために二つのオプションがあります。\n"
"\n"
"最初の一つは、doctestはそれらがルートにある限り、内部構造の比\n"
"較が出来るという、事実に頼ることです。それはこのように畫けま\n"
"す:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    iex> map.users\n"
"    #MapSet<[:foo, :bar]>\n"
"\n"
"doctestは\"#Name<\"で初まる時は何時でも、`doctest`は文字列比較を\n"
"行います。例えば、上のテストは以下のマッチとして動作します:\n"
"\n"
"    inspect(map.users) == \"#MapSet<[:foo, :bar]>\"\n"
"\n"
"もう一つは、doctestの結果は実際に評価されるので、doctestの結\n"
"果として、MapSetを作る式を書くことができます:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], MapSet.new)}\n"
"\n"
"このアプローチの不利な面は、doctestの結果が本当にユーザがター\n"
"ミナルでみる物ではないということです。\n"
"\n"
"## Exceptions\n"
"\n"
"例外を上げる式を紹介することもできます。例えば:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"DocTestは、`**(`で始まる行を探し、それをパースし、それによっ\n"
"て例外名とメッセージを抽出します。現在、例外パーサは、パーサ\n"
"を(`iex>`プレフィックスなら)完全に新しい式の開始か、ドキュメ\n"
"ンとのno-opの行として次の行を扱います。従って、複数行のメッセー\n"
"ジはサポートされていません。\n"
"\n"
"## When not to use doctest\n"
"\n"
"一般に、doctestは副作用を含むコード例では推奨されません。例え\n"
"ば、doctestが標準出力へプリントするなら、doctestは出力を捕捉\n"
"しようとしません。\n"
"\n"
"同様に、doctestは如何なる種類のサンドボックスでも走りません。\n"
"だから、コード例で定義された任意のモジュールは、テストスイー\n"
"トが走る間中、残ります。\n"
