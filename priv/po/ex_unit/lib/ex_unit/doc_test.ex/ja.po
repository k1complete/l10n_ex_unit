msgid ""
msgstr ""
"Project-Id-Version: l 10n_ex_unit\n"
"PO-Revision-Date: 2015-09-27 13:08+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro ExUnit.DocTest.doctest(mod, opts \\ [])
#: lib/ex_unit/doc_test.ex:153
msgid ""
"This macro is used to generate ExUnit test cases for doctests.\n"
"\n"
"Calling `doctest(Module)` will generate tests for all doctests found\n"
"in the module `Module`\n"
"\n"
"Options can also be supplied:\n"
"\n"
"  * `:except` - generate tests for all functions except those listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:only`   - generate tests only for functions listed\n"
"    (list of `{function, arity}` tuples, and/or `:moduledoc`).\n"
"\n"
"  * `:import` - when `true`, one can test a function defined in the module\n"
"    without referring to the module name. However, this is not feasible "
"when\n"
"    there is a clash with a module like Kernel. In these cases, `import`\n"
"    should be set to `false` and a full `M.f` construct should be used.\n"
"\n"
"## Examples\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"This macro is auto-imported with every `ExUnit.Case`.\n"
msgstr ""
"このマクロはdoctestのためのExUnitテストケースを生成するために使\n"
"われます。\n"
"\n"
"`doctest(Module)`を呼ぶと、モジュール`Module`に見付かった、\n"
"全てのdoctestのためのテストを生成します。\n"
"\n"
"以下のオプションも提供されます:\n"
"\n"
"  * `:except` - リストされた関数を除外してテストを生成します\n"
"    (`{function, arity}`タプルと/または:moduledocのリストです)。\n"
"\n"
"  * `:only` - リストされた関数のみのテストを生成します\n"
"    (`{function, arity}`タプルと/または:moduledocのリストです)。\n"
"\n"
"  * `:import` -  `true`のとき、モジュール名を参照することなく、\n"
"    モジュールで定義された関数をテストすることができます。\n"
"    しかしながら、Kernelのようなモジュールとの衝突があるとき、\n"
"    これは可能ではありません。このような場合、`import`は`false`に\n"
"    セットし、完全な`M.f`文法が使われなければなりません。\n"
"\n"
"## 例\n"
"\n"
"    doctest MyModule, except: [:moduledoc, trick_fun: 1]\n"
"\n"
"このマクロは、`ExUnit.Case`毎に自動的にインポートされます。\n"

#. TRANSLATORS: Elixir.ExUnit.DocTest Summary
#: lib/ex_unit/doc_test.ex:2
msgid ""
"ExUnit.DocTest implements functionality similar to [Python's\n"
"doctest](https://docs.python.org/2/library/doctest.html).\n"
"\n"
"In a nutshell, it allows us to generate tests from the code\n"
"examples existing in a module/function/macro's documentation.\n"
"In order to do that, one needs to invoke the `doctest/1` macro\n"
"from their test case and write their examples according\n"
"to some guidelines.\n"
"\n"
"The syntax for examples is as follows. Every new test starts\n"
"on a new line, with an `iex>` prefix. Multiline expressions\n"
"can be employed if the following lines start with either\n"
"`...>` (recommended) or `iex>` prefix.\n"
"\n"
"The expected result should start at the next line after `iex>`\n"
"or `...>` line(s) and is terminated either by a newline, new\n"
"`iex>` prefix or end of the string literal.\n"
"\n"
"## Examples\n"
"\n"
"Currently, the only way to run doctests is to include them into\n"
"an ExUnit case with a `doctest` macro:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"The `doctest` macro is going to loop through all functions and\n"
"macros defined in `MyModule`, parsing their documentation in\n"
"search of code examples.\n"
"\n"
"A very basic example is:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"Expressions on multiple lines are also supported:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"Multiple results can be checked within the same test:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"If you want to keep any two tests separate,\n"
"add an empty line between them:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"function a/0 undefined\" error\n"
"    2\n"
"\n"
"If you don't want to assert for every result in a doctest, you can just "
"omit\n"
"the result:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\n"
"    iex> is_pid(pid)\n"
"    true\n"
"\n"
"This is useful when the result is something variable (like a pid in the\n"
"example above) or when the result is a complicated data structure and you\n"
"don't want to show it all, but just parts of it or some of its properties.\n"
"\n"
"Similarly to IEx you can use numbers in your \"prompts\":\n"
"\n"
"    iex(1)> [1 + 2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"This is useful in two use cases:\n"
"\n"
"  * being able to refer to specific numbered scenarios\n"
"  * copy-pasting examples from an actual IEx session\n"
"\n"
"We also allow you to select or skip some functions when calling\n"
"`doctest`. See the documentation for more info.\n"
"\n"
"## Opaque types\n"
"\n"
"Some types internal structure are kept hidden and instead show a\n"
"user-friendly structure when inspecting the value. The idiom in\n"
"Elixir is to print those data types as `#Name<...>`. Because those\n"
"values are treated as comments in Elixir code due to the leading\n"
"`#` sign, they require special care when used in doctests.\n"
"\n"
"Imagine you have a map with a HashSet inside which is printed as:\n"
"\n"
"    %{users: #HashSet<[:foo, :bar]>}\n"
"\n"
"If you try to match on such expression, `doctest` will fail to compile.\n"
"You have two options to solve this.\n"
"\n"
"The first one is to rely on the fact that doctest can compare internal\n"
"structures as long as they are at the root. So one could write:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], HashSet.new)}\n"
"    iex> map.users\n"
"    #HashSet<[:foo, :bar]>\n"
"\n"
"Whenever a doctest starts with \"#Name<\", `doctest` will perform a string\n"
"comparison. For example, the above test will perform the following match:\n"
"\n"
"    inspect(map.users) == \"#HashSet<[:foo, :bar]>\"\n"
"\n"
"Alternatively, since doctest results are actually evaluated, you can have\n"
"the HashSet building expression as the doctest result:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], HashSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], HashSet.new)}\n"
"\n"
"The downside of this approach is that the doctest result is not really\n"
"what users would see in the terminal.\n"
"\n"
"## Exceptions\n"
"\n"
"You can also showcase expressions raising an exception, for example:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"What DocTest will be looking for is a line starting with `** (` and it\n"
"will parse it accordingly to extract the exception name and message.\n"
"At this moment, the exception parser would make the parser treat the next\n"
"line as a start of a completely new expression (if it is prefixed with "
"`iex>`)\n"
"or a no-op line with documentation. Thus, multiline messages are not\n"
"supported.\n"
"\n"
"## When not to use doctest\n"
"\n"
"In general, doctests are not recommended when your code examples contain\n"
"side effects. For example, if a doctest prints to standard output, doctest\n"
"will not try to capture the output.\n"
"\n"
"Similarly, doctests do not run in any kind of sandbox. So any module\n"
"defined in a code example is going to linger throughout the whole test\n"
"suite run.\n"
msgstr ""
"ExUnit.DocTestは、[Python's doctest](http://docs.python.org/2/library/doctest.html)と似た機能を実装しています。\n"
"\n"
"簡単に言えば、module/function/macroのドキュメントに存在し\n"
"ているコード例から、テストを生成することを許します。\n"
"そうするために、それらのテストケースから`doctest/1`マクロを\n"
"起動する必要と、いくつかのガイドラインに従って、例を\n"
"書く必要があります。\n"
"\n"
"例の構文は下のとおりです。新しいテスト毎に、`iex>`\n"
"プレフィックスで新しい行を始めます。\n"
"後続行が`...>`(推奨)か`iex>`プレフィックスから始まる\n"
"なら、複数行の式が使用できます。\n"
"\n"
"期待される結果は`iex>`か`...>`行の次の行から開始されるべきで、\n"
"それぞれの行は改行され、新しい`iex`プレフィックスか文字列\n"
"リテラルの終了により終了されるべきです。\n"
"\n"
"## 例\n"
"\n"
"現在、doctestを走らせる唯１つの方法は、ExUnitケース中に\n"
"`doctest`マクロを含めることです:\n"
"\n"
"    defmodule MyModule.Test do\n"
"      use ExUnit.Case, async: true\n"
"      doctest MyModule\n"
"    end\n"
"\n"
"`doctest`マクロは、コード例を探してドキュメントをパースしながら、\n"
"`MyModule`で定義された全ての関数とマクロでループするでしょう。\n"
"\n"
"非常に着本的な例は:\n"
"\n"
"    iex> 1+1\n"
"    2\n"
"\n"
"複数行の式もサポートされています:\n"
"\n"
"    iex> Enum.map [1, 2, 3], fn(x) ->\n"
"    ...>   x * 2\n"
"    ...> end\n"
"    [2, 4, 6]\n"
"\n"
"同じテストの中で、複数の結果もチェックさせることができます:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"    iex> a + 1\n"
"    2\n"
"\n"
"任意の二つのテストを分離したいなら、\n"
"間に空行を追加してください:\n"
"\n"
"    iex> a = 1\n"
"    1\n"
"\n"
"    iex> a + 1  # will fail with a \"function a/0 undefined\" error\n"
"    2\n"
"\n"
"もし一々doctestの結果assertしたくないなら、結果を省略できます:\n"
"\n"
"    iex> pid = spawn fn -> :ok end\\n\"\n"
"    iex> is_pid(pid)\\n\"\n"
"    true\\n\"\n"
"\n"
"これは結果が何かの変数(上の例ではpidのような)や、結果が\n"
"難しいデータ構造の時、そして、全てを表示したくはないが、\n"
"その一部やいくつかのプロパティを表示したい場合に便利です。\n"
"\n"
"IExと同様に、\"プロンプト\"に番号を使うことができます:\n"
"\n"
"    iex(1)> [1+2,\n"
"    ...(1)>  3]\n"
"    [3, 3]\n"
"\n"
"これは二つのケースで便利です:\n"
"\n"
"  * 特定の番号付けられたシナリオを参照することができること\n"
"  * 実際のiexセッションからの例のコピーペーストができること\n"
"\n"
"`doctest`を呼ぶとき、関数を選択したりスキップしたりすることも\n"
"出来ます。詳細はドキュメントを参照してください。\n"
"\n"
"## Opaque types\n"
"\n"
"いくつかの内部構造のタイプは隠されたままで、代わりに、\n"
"値をインスペクトするときのユーザフレンドリな構造が、\n"
"表示されます。Elixirのイディオムは、`#Name<...>`として\n"
"それらのデータタイプを表示することです。\n"
"これらの`#`記号で始まる値はElixirコードではコメントとして\n"
"扱われるので、doctestでは使われるとき、特別な注意を要求します。\n"
"\n"
"内部にHashSetを持つマップを持っていてそれを表示したとします:\n"
"\n"
"    %{users: #HashSet<[:foo, :bar]>}\n"
"\n"
"もしそのような式にマッチしようとしたなら、`doctest`はコンパイルに\n"
"失敗します。これを解決するために二つのオプションがあります。\n"
"\n"
"最初の一つは、doctestはそれらがルートにある限り、\n"
"内部構造の比較が出来るという、事実に頼ることです。それは\n"
"このように畫けます:\n"
"\n"
"    iex> map = %{users: Enum.into([:foo, :bar], HashSet.new)}\n"
"    iex> map.users\n"
"    #HashSet<[:foo, :bar]>\n"
"\n"
"doctestは\"#Name<\"で初まる時は何時でも、`doctest`は文字列比較を\n"
"行います。例えば、上のテストは以下のマッチとして動作します:\n"
"\n"
"    inspect(map.users) == \"#HashSet<[:foo, :bar]>\"\n"
"\n"
"もう一つは、doctestの結果は実際に評価されるので、\n"
"doctestの結果として、HashSetを作る式を書くことができます:\n"
"\n"
"    iex> %{users: Enum.into([:foo, :bar], HashSet.new)}\n"
"    %{users: Enum.into([:foo, :bar], HashSet.new)}\n"
"\n"
"doctestは、文字列比較をすることで、これらの値をテストします。\n"
"\n"
"    iex> Enum.into([a: 10, b: 20], HashDict.new)\n"
"    #HashDict<[b: 20, a: 10]>\n"
"\n"
"このアプローチの不利な面は、doctestの結果が本当に\n"
"ユーザがターミナルでみる物ではないということです。\n"
"\n"
"## Exceptions\n"
"\n"
"例外を上げる式を紹介することもできます。例えば:\n"
"\n"
"    iex(1)> String.to_atom((fn() -> 1 end).())\n"
"    ** (ArgumentError) argument error\n"
"\n"
"DocTestは、`**(`で始まる行を探し、それをパースし、それによって\n"
"例外名とメッセージを抽出します。現在、例外パーサは、パーサを\n"
"(`iex>`プレフィックスなら)完全に新しい式の開始か、ドキュメンとの\n"
"no-opの行として次の行を扱います。\n"
"従って、複数行のメッセージはサポートされていません。\n"
"\n"
"## When not to use doctest\n"
"\n"
"一般に、doctestは副作用を含むコード例では推奨されません。\n"
"例えば、doctestが標準出力へプリントするなら、doctestは\n"
"出力を捕捉しようとしません。\n"
"\n"
"同様に、doctestは如何なる種類のサンドボックスでも走りません。\n"
"だから、コード例で定義された任意のモジュールは、テストスイート\n"
"が走る間中、残ります。\n"
