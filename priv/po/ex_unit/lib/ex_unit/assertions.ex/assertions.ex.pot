#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:116 
msgid ""
"This is a negative assertion, failing if its parameter\n"
"is truthy.\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:12 
msgid ""
"Indicates no meaningful value for a field.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:17 
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro tries to be smart\n"
"and provide good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns 13):\n"
"\n"
"   Comparison (using ==) failed in:\n"
"   code: some_fun() == 10\n"
"   lhs:  13\n"
"   rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle other\n"
"common cases such as checking a floating point number or handling exceptions.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:559 
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:358 
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:332 
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the `expected_message`. Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", fn ->\n"
"      1 + \"test\"\n"
"    end\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:389 
msgid ""
"Asserts that `val1` and `val2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:66 
msgid ""
"Asserts its argument is true.\n"
"\n"
"`assert` tries to be smart and provide good\n"
"reporting whenever there is a failure. In particular, if\n"
"given a match expression, it will report any failure in terms\n"
"of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"If the expression is a comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(expected, message \\ nil)
#: lib/ex_unit/assertions.ex:270 
msgid ""
"Asserts a message was received and is in the current process' mailbox.\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:249 
msgid ""
"Asserts a message was or is going to be received. Unlike\n"
"`assert_received`, it has a default timeout of 100 milliseconds.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(not_expected, message \\ nil)
#: lib/ex_unit/assertions.ex:495 
msgid ""
"Asserts a message was not received (i.e. it is not in the current process mailbox).\n"
"The `not_expected` argument must be a match pattern.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert(value, left, right, message)
#: lib/ex_unit/assertions.ex:223 
msgid ""
"Asserts `value` is true.\n"
"If it fails, it raises an expectation error\n"
"using the given `left` and `right` values.\n"
"\n"
"You probably don't need to use thisâ€”the regular `assert` function\n"
"handles this for you.\n"
"\n"
"## Examples\n"
"\n"
"    assert this > that, this, that, \"more than\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:201 
msgid ""
"Asserts `value` is true, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:458 
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:537 
msgid ""
"Asserts `val1` and `val2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:406 
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:419 
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:432 
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(not_expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:479 
msgid ""
"    refute_receive message, timeout \\ 100, message \\ nil\n"
"\n"
"Asserts `message` was not received (and won't be received) within\n"
"the `timeout` period.\n"
"\n"
"The `not_expected` argument is a match pattern.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with a explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
