msgid ""
msgstr ""
"Project-Id-Version: l 10n_ex_unit\n"
"PO-Revision-Date: 2015-12-27 12:40+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:659
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
"メッセージ付きで失敗します。\n"
"\n"
"## 例\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:256
msgid ""
"Asserts `value` is `true`, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
"`value`が`true`と表明し、さもなければ与えられた`message`を\n"
"表示します。\n"
"\n"
"## 例\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:457
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
"`function`実行中に`exception`が上ると表明します。\n"
"レスキューされた例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:56
msgid ""
"Asserts its argument is a truthy value.\n"
"\n"
"`assert` instrospects the underlying expression and provide\n"
"good  reporting whenever there is a failure. For example,\n"
"if the expression uses the comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
"\n"
"Similarly, if a match expression is given, it will report\n"
"any failure in terms of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"Keep in mind that `assert` does not change its semantics\n"
"based on the expression. In other words, the expression\n"
"is still required to return a truthy value. For example,\n"
"the following will fail:\n"
"\n"
"    assert nil = some_function_that_returns_nil()\n"
"\n"
"Even though the match works, `assert` still expects a truth\n"
"value. In such cases, simply use `Kernel.==/2` or\n"
"`Kernel.match?/2`.\n"
msgstr ""
"引数が真の値であると表明します。\n"
"`asssert`は失敗したときは何時でも、根底の式の内部を確認し、\n"
"良いレポートを提供します。例えば、もし式が比較演算子を使ったら、\n"
"メッセージは両辺の値を表示するでしょう。\n"
"以下のassertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
"は、以下のメッセージで失敗します:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
"\n"
"同様に、マッチ式が与えられると、そのマッチのタームの\n"
"どんな失敗でもレポートします。以下の\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"は、こうなります:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"`assert`は式に基いたセマンティクスを変えないことに\n"
"注意してください。言い替えると、まだ式は真となる値を\n"
"返すことを要求しています。例えば、以下は失敗します:\n"
"\n"
"    assert nil = some_function_that_returns_nil()\n"
"\n"
"例えマッチがきちんと動いていても、`assert`は真となる\n"
"値を予期しています。この場合、単に`Kernel.==/2`か\n"
"`Kernel.match?/2`を使ってください。\n"

#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:13
msgid "Indicates no meaningful value for a field.\n"
msgstr "フィールドに意味のある値が無いことを示します。\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(expected, message \\ nil)
#: lib/ex_unit/assertions.ex:303
msgid ""
"Asserts a message was received and is in the current process' mailbox.\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
"メッセージが受信され、現在のプロセスのmailboxに\n"
"あると表明します。\n"
"タイムアウトを0にセットすると、待ちません。\n"
"\n"
"`expected`引数はパターンです。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(not_expected, timeout \\ Application.fetch_env!(:ex_unit, :refute_receive_timeout), message \\ nil)
#: lib/ex_unit/assertions.ex:572
msgid ""
"Asserts `message` was not received (and won't be received) within\n"
"the `timeout` period.\n"
"\n"
"The `not_expected` argument is a match pattern.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with an explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
"`message`が`timeout`の間に受信されなかった(そして\n"
"受信されないだろう)という表明です。\n"
"\n"
"`not_expected`引数はマッチパターンです。\n"
"\n"
"## 例\n"
"\n"
"    refute_receive :bye\n"
"\n"
"明示的なタイムアウト付で受信されないだろうことを表明します:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(value1, value2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:489
msgid ""
"Asserts that `value1` and `value2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
"`value1`と`value2`の差が`delta`より小さいと表明します。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:533
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
"`expression`がerrorを引き起すという表明です。\n"
"errorを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:35
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro introspects your code\n"
"and provide good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns 13):\n"
"\n"
"    Comparison (using ==) failed in:\n"
"    code: some_fun() == 10\n"
"    lhs:  13\n"
"    rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle\n"
"other common cases such as checking a floating point number\n"
"or handling exceptions.\n"
msgstr ""
"このモジュールは一組のアサーション関数を含み、\n"
"デフォルトでテストケースにインポートされます。\n"
"\n"
"一般に、開発者はテストにおいて、一般的な`assert`マクロを\n"
"使いたい。このマクロは、失敗したときは何時でも、よいレポートを\n"
"提供するようとします。\n"
"例えば、`assert sum_fun() == 10`が失敗すると(\n"
"`sum_fun()`が13を返したとします):\n"
"\n"
"    Comparison (using ==) failed in:\n"
"    code: some_fun() == 10\n"
"    lhs:  13\n"
"    rhs:  10\n"
"\n"
"このモジュールは、浮動小数点数のチェックや例外の\n"
"ハンドリングといった他の共通のケースを簡単に扱う、\n"
"`assert_in_delta`や`assert_raise`\n"
"のような、他の便利な関数も提供します。\n"

#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(value1, value2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:635
msgid ""
"Asserts `value1` and `value2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
"`value1`と`value2`が`delta`の間にないという表明です。\n"
"\n"
"もし`message`があれば、値についての情報は、自動的に\n"
"それに追加されます。\n"
"\n"
"## 例\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:424
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the expected `message`, which can be a `Regex` or an exact `String`.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
"    assert_raise RuntimeError, ~r/^Today's lucky number is 0.+!$/, fn ->\n"
"      raise \"Today's lucky number is 0.4379087006197395!\"\n"
"    end\n"
msgstr ""
"`function`実行中に予期された`message`で`exception`が上ると表\n"
"明します。`message`は`Regex`あるいは、正確な`String`を使うこ\n"
"とができます。レスキューされた例外を返し、さもなくば失敗しま\n"
"す。\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
"    assert_raise RuntimeError, ~r/^Today's lucky number is 0.+!$/, fn ->\n"
"      raise \"Today's lucky number is 0.4379087006197395!\"\n"
"    end\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:507
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
"`expression`が値をthrowするという表明です。\n"
"throwされた値を返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:520
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
"`expression`がexitするという表明です。\n"
"exit status/メッセージを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(not_expected, message \\ nil)
#: lib/ex_unit/assertions.ex:593
msgid ""
"Asserts a message was not received (i.e. it is not in the current process "
"mailbox).\n"
"The `not_expected` argument must be a match pattern.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"
msgstr ""
"メッセージが受信されていないと表明します(即ち、\n"
"現在のプロセスのmailboxにはないということです)。\n"
"`not_expected`引数はマッチパターンでなければなりません。\n"
"\n"
"タイムアウトに0をセットすると、待ちません。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(expected, timeout \\ Application.fetch_env!(:ex_unit, :assert_receive_timeout), message \\ nil)
#: lib/ex_unit/assertions.ex:273
msgid ""
"Asserts a message was or is going to be received.\n"
"\n"
"Unlike `assert_received`, it has a default timeout\n"
"of 100 milliseconds.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
"メッセージが受信されたか、受信されようとしていると表明\n"
"します。\n"
"\n"
"`assert_received`と違って、100ミリ秒のデフォルトタイムアウトを\n"
"持ちます。\n"
"\n"
"`expected`引数はパターンです。\n"
"\n"
"## 例\n"
"\n"
"    assert_receive :hello\n"
"\n"
"大きなタイムアウトに対して表明します:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:560
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
"`value`が`nil`か`false`である(つまり、`value`は真ではない)という表明です。\n"
"\n"
"## 例\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:165
msgid ""
"A negative assertion, expects the expression to be `false` or `nil`.\n"
"\n"
"Keep in mind that `refute` does not change the semantics of\n"
"the given expression. In other words, the following will fail:\n"
"\n"
"    refute {:ok, _} = some_function_that_returns_error_tuple()\n"
"\n"
"The code above will fail because the `=` operator always fails\n"
"when the sides do not match and `refute/2` does not change it.\n"
"\n"
"The correct way to write the refutation above is to use\n"
"`Kernel.match?/2`:\n"
"\n"
"    refute match? {:ok, _}, some_function_that_returns_error_tuple()\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
"否定的なアサーションで、パラメタが`false`か`nil`であることを\n"
"期待します。\n"
"\n"
"`refute`は与えられた式のセマンティクスを変更しないことに\n"
"注意してください。言い替えると、以下は失敗します:\n"
"\n"
"    refute {:ok, _} = some_function_that_returns_error_tuple()\n"
"\n"
"`=`オペレータはマッチしない時は失敗します。そして、`refute/2`は\n"
"その振る舞いを変えないので、上のコードは失敗ます。\n"
"\n"
"上のrefutationの正しい方法は`Kernel.match?/2`を使うことです:\n"
"\n"
"    refute match? {:ok, _}, some_function_that_returns_error_tuple()\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"

#. TRANSLATORS: Elixir.ExUnit.AssertionError Summary
#: lib/ex_unit/assertions.ex:2
msgid "Raised to signal an assertion error.\n"
msgstr "アサーションエラーのシグナル\n"

#. TRANSLATORS: Elixir.ExUnit.MultiError Summary
#: lib/ex_unit/assertions.ex:22
msgid "Raised to signal multiple errors happened in a test case.\n"
msgstr "test caseで複数のエラー発生のシグナル\n"

#~ msgid ""
#~ "This is a negative assertion, failing if its parameter\n"
#~ "is truthy.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    refute age < 0\n"
#~ "\n"
#~ msgstr ""
#~ "これは否定的なアサーションで、パラメタがtrueなら失敗します。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    refute age < 0\n"
#~ "\n"

#~ msgid ""
#~ "Asserts its argument is `true`.\n"
#~ "\n"
#~ "`assert` tries to be smart and provide good\n"
#~ "reporting whenever there is a failure. In particular, if\n"
#~ "given a match expression, it will report any failure in terms\n"
#~ "of that match. Given\n"
#~ "\n"
#~ "    assert [one] = [two]\n"
#~ "\n"
#~ "you'll see:\n"
#~ "\n"
#~ "    match (=) failed\n"
#~ "    code: [one] = [two]\n"
#~ "    rhs:  [2]\n"
#~ "\n"
#~ "If the expression is a comparison operator, the message\n"
#~ "will show the values of the two sides. The assertion\n"
#~ "\n"
#~ "    assert 1+2+3+4 > 15\n"
#~ "\n"
#~ " will fail with the message:\n"
#~ "\n"
#~ "    Assertion with > failed\n"
#~ "    code: 1+2+3+4 > 15\n"
#~ "    lhs:  10\n"
#~ "    rhs:  15\n"
#~ msgstr ""
#~ "引数が`true`であると表明します。\n"
#~ "\n"
#~ "`assert`は、失敗があるときは何時でも\n"
#~ "スマートでよい報告を提供しようとします。\n"
#~ "特に、マッチ式が与えられたなら、その\n"
#~ "マッチに関してどんな失敗もレポートします。\n"
#~ "以下が与えられたとして\n"
#~ "\n"
#~ "    assert [one] = [two]\n"
#~ "\n"
#~ "以下をみることになります:\n"
#~ "\n"
#~ "    match (=) failed\n"
#~ "    code: [one] = [two]\n"
#~ "    rhs:  [2]\n"
#~ "\n"
#~ "もし式が比較演算子なら、メッセージが\n"
#~ "式の両側の値を表示します。以下のアサーションは、\n"
#~ "\n"
#~ "    assert 1+2+3+4 > 15\n"
#~ "\n"
#~ "以下のメッセージを伴って失敗するでしょう:\n"
#~ "\n"
#~ "    Assertion with > failed\n"
#~ "    code: 1+2+3+4 > 15\n"
#~ "    lhs:  10\n"
#~ "    rhs:  15\n"

#~ msgid ""
#~ "Asserts `value` is true.\n"
#~ "If it fails, it raises an expectation error\n"
#~ "using the given `left` and `right` values.\n"
#~ "\n"
#~ "You probably don't need to use this—the regular `assert` function\n"
#~ "handles this for you.\n"
#~ "\n"
#~ "## Examples\n"
#~ "\n"
#~ "    assert this > that, this, that, \"more than\"\n"
#~ "\n"
#~ msgstr ""
#~ "`value`がtrueと表明します。\n"
#~ "もし失敗すると、与えられた`left`と`right`の値を使って\n"
#~ "エラー例外を上げます。\n"
#~ "\n"
#~ "たぶん、これをそのように扱う「この標準の」`assert`関数を\n"
#~ "使う必要はないでしょう。\n"
#~ "\n"
#~ "## 例\n"
#~ "\n"
#~ "    assert this > that, this, that, \"more than\"\n"
#~ "\n"
