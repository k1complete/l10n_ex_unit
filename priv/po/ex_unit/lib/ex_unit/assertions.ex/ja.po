msgid ""
msgstr ""
"Project-Id-Version: l 10n_ex_unit\n"
"PO-Revision-Date: 2015-05-20 22:34+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute(assertion)
#: lib/ex_unit/assertions.ex:116
msgid ""
"This is a negative assertion, failing if its parameter\n"
"is truthy.\n"
"\n"
"## Examples\n"
"\n"
"    refute age < 0\n"
"\n"
msgstr ""
"これは否定的なアサーションで、パラメタがtrueなら失敗します。\n"
"\n"
"## 例\n"
"\n"
"    refute age < 0\n"
"\n"

#. TRANSLATORS: def ExUnit.AssertionError.no_value()
#: lib/ex_unit/assertions.ex:12
msgid "Indicates no meaningful value for a field.\n"
msgstr "フィールドに意味のある値が無いことを示します。\n"

#. TRANSLATORS: Elixir.ExUnit.Assertions Summary
#: lib/ex_unit/assertions.ex:17
msgid ""
"This module contains a set of assertion functions that are\n"
"imported by default into your test cases.\n"
"\n"
"In general, a developer will want to use the general\n"
"`assert` macro in tests. This macro tries to be smart\n"
"and provide good reporting whenever there is a failure.\n"
"For example, `assert some_fun() == 10` will fail (assuming\n"
"`some_fun()` returns 13):\n"
"\n"
"   Comparison (using ==) failed in:\n"
"   code: some_fun() == 10\n"
"   lhs:  13\n"
"   rhs:  10\n"
"\n"
"This module also provides other convenience functions\n"
"like `assert_in_delta` and `assert_raise` to easily handle other\n"
"common cases such as checking a floating point number or handling "
"exceptions.\n"
msgstr ""
"このモジュールは一組のアサーション関数を含み、\n"
"デフォルトでテストケースにインポートされます。\n"
"\n"
"一般に、開発者はテストにおいて、一般的な`assert`マクロを\n"
"使いたい。このマクロは、失敗したときは何時でも、\n"
"スマートでよいレポートを提供するようとします。\n"
"例えば、`assert sum_fun() == 10`が失敗すると(\n"
"`sum_fun()`が13を返したとします):\n"
"\n"
"   Comparison (using ==) failed in:\n"
"   code: some_fun() == 10\n"
"   lhs:  13\n"
"   rhs:  10\n"
"\n"
"このモジュールは、浮動小数点数のチェックや例外の\n"
"ハンドリングといった他の共通のケースを簡単に扱う、\n"
"`assert_in_delta`や`assert_raise`\n"
"のような、他の便利な関数も提供します。\n"

#. TRANSLATORS: def ExUnit.Assertions.flunk(message \\ "Flunked!")
#: lib/ex_unit/assertions.ex:559
msgid ""
"Fails with a message.\n"
"\n"
"## Examples\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"
msgstr ""
"メッセージ付きで失敗します。\n"
"\n"
"## 例\n"
"\n"
"    flunk \"This should raise an error\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, function)
#: lib/ex_unit/assertions.ex:358
msgid ""
"Asserts the `exception` is raised during `function` execution.\n"
"Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"
msgstr ""
"`function`実行中に`exception`が上ると表明します。\n"
"レスキューされた例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, fn ->\n"
"      1 + \"test\"\n"
"    end\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_raise(exception, message, function)
#: lib/ex_unit/assertions.ex:332
msgid ""
"Asserts the `exception` is raised during `function` execution with\n"
"the `expected_message`. Returns the rescued exception, fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"
msgstr ""
"`function`実行中に`excepted_message`が上ると表明します。\n"
"レスキューされた例外を返し、さもなくば失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert_raise ArithmeticError, \"bad argument in arithmetic expression\", "
"fn ->\n"
"      1 + \"test\"\n"
"    end\n"

#. TRANSLATORS: def ExUnit.Assertions.assert_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:389
msgid ""
"Asserts that `val1` and `val2` differ by no more than `delta`.\n"
"\n"
"\n"
"## Examples\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"
msgstr ""
"`val1`と`val2`の差が`delta`より小さいと表明します。\n"
"\n"
"\n"
"## 例\n"
"\n"
"    assert_in_delta 1.1, 1.5, 0.2\n"
"    assert_in_delta 10, 15, 4\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert(assertion)
#: lib/ex_unit/assertions.ex:66
msgid ""
"Asserts its argument is true.\n"
"\n"
"`assert` tries to be smart and provide good\n"
"reporting whenever there is a failure. In particular, if\n"
"given a match expression, it will report any failure in terms\n"
"of that match. Given\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"you'll see:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"If the expression is a comparison operator, the message\n"
"will show the values of the two sides. The assertion\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
" will fail with the message:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"
msgstr ""
"引数がtrueであると表明します。\n"
"\n"
"`assert`は、失敗があるときは何時でも\n"
"スマートでよい報告を提供しようとします。\n"
"特に、マッチ式が与えられたなら、その\n"
"マッチに関してどんな失敗もレポートします。\n"
"以下が与えられたとして\n"
"\n"
"    assert [one] = [two]\n"
"\n"
"以下をみることになります:\n"
"\n"
"    match (=) failed\n"
"    code: [one] = [two]\n"
"    rhs:  [2]\n"
"\n"
"もし式が比較演算子なら、メッセージが\n"
"式の両側の値を表示します。以下のアサーションは、\n"
"\n"
"    assert 1+2+3+4 > 15\n"
"\n"
"以下のメッセージを伴って失敗するでしょう:\n"
"\n"
"    Assertion with > failed\n"
"    code: 1+2+3+4 > 15\n"
"    lhs:  10\n"
"    rhs:  15\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_received(expected, message \\ nil)
#: lib/ex_unit/assertions.ex:270
msgid ""
"Asserts a message was received and is in the current process' mailbox.\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"
msgstr ""
"メッセージが受信され、現在のプロセスのmailboxに\n"
"あると表明します。\n"
"タイムアウトを0にセットすると、待ちません。\n"
"\n"
"`expected`引数はパターンです。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    assert_received :hello\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    send self, {:hello, \"world\"}\n"
"    assert_received {:hello, _}\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.assert_receive(expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:249
msgid ""
"Asserts a message was or is going to be received. Unlike\n"
"`assert_received`, it has a default timeout of 100 milliseconds.\n"
"\n"
"The `expected` argument is a pattern.\n"
"\n"
"## Examples\n"
"\n"
"    assert_receive :hello\n"
"\n"
"Asserts against a larger timeout:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"You can also match against specific patterns:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"
msgstr ""
"メッセージが受信されたか、受信されようとしていると表明\n"
"します。`assert_received`と違って、\n"
"100ミリ秒のデフォルトタイムアウトを持ちます。\n"
"\n"
"`expected`引数はパターンです。\n"
"\n"
"## 例\n"
"\n"
"    assert_receive :hello\n"
"\n"
"大きなタイムアウトに対して表明します:\n"
"\n"
"    assert_receive :hello, 20_000\n"
"\n"
"特定のパターンに対してマッチさせることもできます:\n"
"\n"
"    assert_receive {:hello, _}\n"
"\n"
"    x = 5\n"
"    assert_receive {:count, ^x}\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_received(not_expected, message \\ nil)
#: lib/ex_unit/assertions.ex:495
msgid ""
"Asserts a message was not received (i.e. it is not in the current process "
"mailbox).\n"
"The `not_expected` argument must be a match pattern.\n"
"\n"
"Timeout is set to 0, so there is no waiting time.\n"
"\n"
"## Examples\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"
msgstr ""
"メッセージが受信されていないと表明します(即ち、\n"
"現在のプロセスのmailboxにはないということです)。\n"
"`not_expected`引数はマッチパターンでなければなりません。\n"
"\n"
"タイムアウトに0をセットすると、待ちません。\n"
"\n"
"## 例\n"
"\n"
"    send self, :hello\n"
"    refute_received :bye\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert(value, left, right, message)
#: lib/ex_unit/assertions.ex:223
msgid ""
"Asserts `value` is true.\n"
"If it fails, it raises an expectation error\n"
"using the given `left` and `right` values.\n"
"\n"
"You probably don't need to use this—the regular `assert` function\n"
"handles this for you.\n"
"\n"
"## Examples\n"
"\n"
"    assert this > that, this, that, \"more than\"\n"
"\n"
msgstr ""
"`value`がtrueと表明します。\n"
"もし失敗すると、与えられた`left`と`right`の値を使って\n"
"エラー例外を上げます。\n"
"\n"
"たぶん、これをそのように扱う「この標準の」`assert`関数を\n"
"使う必要はないでしょう。\n"
"\n"
"## 例\n"
"\n"
"    assert this > that, this, that, \"more than\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.assert(value, message)
#: lib/ex_unit/assertions.ex:201
msgid ""
"Asserts `value` is true, displaying the given `message` otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"
msgstr ""
"`value`がtrueと表明し、さもなければ与えられた`message`を\n"
"表示します。\n"
"\n"
"## 例\n"
"\n"
"    assert false, \"it will never be true\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute(value, message)
#: lib/ex_unit/assertions.ex:458
msgid ""
"Asserts `value` is `nil` or `false` (that is, `value` is not truthy).\n"
"\n"
"## Examples\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"
msgstr ""
"`value`が`nil`か`false`である(つまり、`value`は真ではない)という表明です。\n"
"\n"
"## 例\n"
"\n"
"    refute true, \"This will obviously fail\"\n"
"\n"

#. TRANSLATORS: def ExUnit.Assertions.refute_in_delta(val1, val2, delta, message \\ nil)
#: lib/ex_unit/assertions.ex:537
msgid ""
"Asserts `val1` and `val2` are not within `delta`.\n"
"\n"
"If you supply `message`, information about the values will\n"
"automatically be appended to it.\n"
"\n"
"## Examples\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"
msgstr ""
"`val1`と`val2`が`delta`の間にないという表明です。\n"
"\n"
"もし`message`があれば、値についての情報は、自動的に\n"
"それに追加されます。\n"
"\n"
"## 例\n"
"\n"
"    refute_in_delta 1.1, 1.2, 0.2\n"
"    refute_in_delta 10, 11, 2\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_throw(expression)
#: lib/ex_unit/assertions.ex:406
msgid ""
"Asserts `expression` will throw a value.\n"
"Returns the thrown value or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"
msgstr ""
"`expression`が値をthrowするという表明です。\n"
"throwされた値を返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_throw(throw 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_exit(expression)
#: lib/ex_unit/assertions.ex:419
msgid ""
"Asserts `expression` will exit.\n"
"Returns the exit status/message or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"
msgstr ""
"`expression`がexitするという表明です。\n"
"exit status/メッセージを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_exit(exit 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.catch_error(expression)
#: lib/ex_unit/assertions.ex:432
msgid ""
"Asserts `expression` will cause an error.\n"
"Returns the error or fails otherwise.\n"
"\n"
"## Examples\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"
msgstr ""
"`expression`がerrorを引き起すという表明です。\n"
"errorを返します。さもなければ失敗します。\n"
"\n"
"## 例\n"
"\n"
"    assert catch_error(error 1) == 1\n"
"\n"

#. TRANSLATORS: defmacro ExUnit.Assertions.refute_receive(not_expected, timeout \\ 100, message \\ nil)
#: lib/ex_unit/assertions.ex:479
msgid ""
"    refute_receive message, timeout \\ 100, message \\ nil\n"
"\n"
"Asserts `message` was not received (and won't be received) within\n"
"the `timeout` period.\n"
"\n"
"The `not_expected` argument is a match pattern.\n"
"\n"
"## Examples\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with a explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
msgstr ""
"    refute_receive message, timeout \\ 100, message \\ nil\n"
"\n"
"`message`が`timeout`の間に受信されなかった(そして\n"
"受信されないだろう)という表明です。\n"
"\n"
"`not_expected`引数はマッチパターンです。\n"
"\n"
"## 例\n"
"\n"
"    refute_receive :bye\n"
"\n"
"Refute received with a explicit timeout:\n"
"\n"
"    refute_receive :bye, 1000\n"
"\n"
