#. TRANSLATORS: def ExUnit.CaptureLog.capture_log(opts \\ [], fun)
#: lib/ex_unit/capture_log.ex:34 
msgid ""
"Captures Logger messages generated when evaluating `fun`.\n"
"\n"
"Returns the binary which is the captured output.\n"
"\n"
"This function mutes the `:console` backend\n"
"and captures any log messages sent to Logger.\n"
"\n"
"Note that when the `async` is set to `true`,\n"
"the messages from another test might be captured.\n"
"\n"
"It is possible to configure the level to capture with `:level`,\n"
"which will set the capturing level for the duration of the\n"
"capture, for instance, if the log level is set to :error\n"
"any message with the lower level will be ignored.\n"
"The default level is `nil`, which will capture all messages.\n"
"The behaviour is undetermined if async tests change Logger level.\n"
"\n"
"The format, metadata and colors can be configured with `:format`,\n"
"`:metadata` and `:colors` respectively. These three options\n"
"defaults to the `:console` backend configuration parameters.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.CaptureLog Summary
#: lib/ex_unit/capture_log.ex:2 
msgid ""
"Functionality to capture logs for testing.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case\n"
"\n"
"      import ExUnit.CaptureLog\n"
"\n"
"      test \"example\" do\n"
"        assert capture_log(fn ->\n"
"          Logger.error \"log msg\"\n"
"        end) =~ \"log msg\"\n"
"      end\n"
"\n"
"      test \"check multiple captures concurrently\" do\n"
"        fun = fn ->\n"
"          for msg <- [\"hello\", \"hi\"] do\n"
"            assert capture_log(fn -> Logger.error msg end) =~ msg\n"
"          end\n"
"          Logger.debug \"testing\"\n"
"        end\n"
"        assert capture_log(fun) =~ \"hello\"\n"
"        assert capture_log(fun) =~ \"testing\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
