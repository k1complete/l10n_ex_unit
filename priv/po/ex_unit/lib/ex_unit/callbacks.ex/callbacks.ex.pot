#. TRANSLATORS: defmacro ExUnit.Callbacks.setup(var \\ quote() do;  _;end, block)
#: lib/ex_unit/callbacks.ex:105 
msgid ""
"Defines a callback to be run before each test in a case.\n"
msgstr ""
#. TRANSLATORS: defmacro ExUnit.Callbacks.setup_all(var \\ quote() do;  _;end, block)
#: lib/ex_unit/callbacks.ex:116 
msgid ""
"Defines a callback to be run before all tests in a case.\n"
msgstr ""
#. TRANSLATORS: def ExUnit.Callbacks.on_exit(ref \\ make_ref, callback)
#: lib/ex_unit/callbacks.ex:127 
msgid ""
"Defines a callback that runs on the test (or test case) exit.\n"
"\n"
"An `on_exit` callback is a function that receives no arguments and\n"
"runs in a separate process than the caller.\n"
"\n"
"`on_exit/2` is usually called from `setup` and `setup_all` callbacks,\n"
"often to undo the action performed during `setup`. However, `on_exit`\n"
"may also be called dynamically, where a reference can be used to\n"
"guarantee the callback will be invoked only once.\n"
msgstr ""
#. TRANSLATORS: Elixir.ExUnit.Callbacks Summary
#: lib/ex_unit/callbacks.ex:2 
msgid ""
"Defines ExUnit Callbacks.\n"
"\n"
"This module defines both `setup_all` and `setup` callbacks, as well as\n"
"the `on_exit` facility.\n"
"\n"
"The setup callbacks are defined via macros and each one can optionally\n"
"receive a map with metadata, usually referred to as `context`. The\n"
"callback may optionally put extra data into `context` to be used in\n"
"the tests.\n"
"\n"
"The `setup_all` callbacks are invoked once to setup the test case before any\n"
"test is run and all `setup` callbacks are run before each test. No callback\n"
"runs if the test case has no tests or all tests were filtered out.\n"
"\n"
"`on_exit` callbacks are registered on demand, usually to undo an action\n"
"performed by a setup callback. `on_exit` may also take a reference,\n"
"allowing callback to be overridden in the future. A registered `on_exit`\n"
"callback always runs, while failures in `setup` and `setup_all` will stop\n"
"all remaining setup callbacks from executing.\n"
"\n"
"Finally, `setup_all` callbacks run in the test case process, while all\n"
"`setup` callbacks run in the same process as the test itself. `on_exit`\n"
"callbacks always run in a separate process than the test case or the\n"
"test itself. Since the test process exits with reason `:shutdown`, most\n"
"of times `on_exit/1` can be avoided as processes are going to clean\n"
"up on their own.\n"
"\n"
"## Context\n"
"\n"
"If you return `{:ok, <dict>}` from `setup_all`, the dictionary\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup_all`, `setup` and the test itself.\n"
"\n"
"Similarly, returning `{:ok, <dict>}` from `setup`, the dict returned\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup` and the `test` itself.\n"
"\n"
"Returning `:ok` leaves the context unchanged in both cases.\n"
"\n"
"Returning anything else from `setup_all` will force all tests to fail,\n"
"while a bad response from `setup` causes the current test to fail.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # \"setup_all\" is called once to setup the case before any test is run\n"
"      setup_all do\n"
"        IO.puts \"Starting AssertionTest\"\n"
"\n"
"        # No metadata\n"
"        :ok\n"
"      end\n"
"\n"
"      # \"setup\" is called before each test is run\n"
"      setup do\n"
"        IO.puts \"This is a setup callback\"\n"
"\n"
"        on_exit fn ->\n"
"          IO.puts \"This is invoked once the test is done\"\n"
"        end\n"
"\n"
"        # Returns extra metadata, it must be a dict\n"
"        {:ok, hello: \"world\"}\n"
"      end\n"
"\n"
"      # Same as \"setup\", but receives the context\n"
"      # for the current test\n"
"      setup context do\n"
"        IO.puts \"Setting up: #{context[:test]}\"\n"
"        :ok\n"
"      end\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"\n"
"      test \"another one\", context do\n"
"        assert context[:hello] == \"world\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
