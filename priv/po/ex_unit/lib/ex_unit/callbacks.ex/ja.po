msgid ""
msgstr ""
"Project-Id-Version: l 10n_ex_unit\n"
"PO-Revision-Date: 2015-09-27 11:53+0900\n"
"Last-Translator: 小田 照敬 <EMAIL@ADDRESS>\n"
"Language-Team: Japanese\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. TRANSLATORS: defmacro ExUnit.Callbacks.setup(var \\ quote() do;  _;end, block)
#: lib/ex_unit/callbacks.ex:105
msgid "Defines a callback to be run before each test in a case.\n"
msgstr ""
"ケースでそれぞれのテストの前に走らせるべきコールバックを\n"
"定義します。\n"

#. TRANSLATORS: defmacro ExUnit.Callbacks.setup_all(var \\ quote() do;  _;end, block)
#: lib/ex_unit/callbacks.ex:116
msgid "Defines a callback to be run before all tests in a case.\n"
msgstr ""
"ケースで全てのテストの前に走らせるべきコールバックを\n"
"定義します。\n"

#. TRANSLATORS: def ExUnit.Callbacks.on_exit(ref \\ make_ref, callback)
#: lib/ex_unit/callbacks.ex:127
msgid ""
"Defines a callback that runs on the test (or test case) exit.\n"
"\n"
"An `on_exit` callback is a function that receives no arguments and\n"
"runs in a separate process than the caller.\n"
"\n"
"`on_exit/2` is usually called from `setup` and `setup_all` callbacks,\n"
"often to undo the action performed during `setup`. However, `on_exit`\n"
"may also be called dynamically, where a reference can be used to\n"
"guarantee the callback will be invoked only once.\n"
msgstr ""
"テスト(またはテストケース)がexitする時に走らせるべき\n"
"コールバックを定義します。\n"
"\n"
"`on_exit`コールバックは、引数なしで、呼び出し側とは別の\n"
"プロセスで走る関数です。\n"
"\n"
"`on_exit/2`は、しばしば、`setup`の間に、実行されたアクションを\n"
"取り消すために、よく、`setup`や`setup_all`コールバックから呼ば\n"
"れます。\n"
"しかしながら、`on_exit`は動的にも呼ばれるかもしれません。\n"
"そこでは、リファレンスがコールバックが一度だけ起動される\n"
"ことを保証するために使われます。\n"

#. TRANSLATORS: Elixir.ExUnit.Callbacks Summary
#: lib/ex_unit/callbacks.ex:2
msgid ""
"Defines ExUnit Callbacks.\n"
"\n"
"This module defines both `setup_all` and `setup` callbacks, as well as\n"
"the `on_exit` facility.\n"
"\n"
"The setup callbacks are defined via macros and each one can optionally\n"
"receive a map with metadata, usually referred to as `context`. The\n"
"callback may optionally put extra data into `context` to be used in\n"
"the tests.\n"
"\n"
"The `setup_all` callbacks are invoked once to setup the test case before "
"any\n"
"test is run and all `setup` callbacks are run before each test. No callback\n"
"runs if the test case has no tests or all tests were filtered out.\n"
"\n"
"`on_exit` callbacks are registered on demand, usually to undo an action\n"
"performed by a setup callback. `on_exit` may also take a reference,\n"
"allowing callback to be overridden in the future. A registered `on_exit`\n"
"callback always runs, while failures in `setup` and `setup_all` will stop\n"
"all remaining setup callbacks from executing.\n"
"\n"
"Finally, `setup_all` callbacks run in the test case process, while all\n"
"`setup` callbacks run in the same process as the test itself. `on_exit`\n"
"callbacks always run in a separate process than the test case or the\n"
"test itself. Since the test process exits with reason `:shutdown`, most\n"
"of times `on_exit/1` can be avoided as processes are going to clean\n"
"up on their own.\n"
"\n"
"## Context\n"
"\n"
"If you return `{:ok, <dict>}` from `setup_all`, the dictionary\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup_all`, `setup` and the test itself.\n"
"\n"
"Similarly, returning `{:ok, <dict>}` from `setup`, the dict returned\n"
"will be merged into the current context and be available in all\n"
"subsequent `setup` and the `test` itself.\n"
"\n"
"Returning `:ok` leaves the context unchanged in both cases.\n"
"\n"
"Returning anything else from `setup_all` will force all tests to fail,\n"
"while a bad response from `setup` causes the current test to fail.\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # \"setup_all\" is called once to setup the case before any test is "
"run\n"
"      setup_all do\n"
"        IO.puts \"Starting AssertionTest\"\n"
"\n"
"        # No metadata\n"
"        :ok\n"
"      end\n"
"\n"
"      # \"setup\" is called before each test is run\n"
"      setup do\n"
"        IO.puts \"This is a setup callback\"\n"
"\n"
"        on_exit fn ->\n"
"          IO.puts \"This is invoked once the test is done\"\n"
"        end\n"
"\n"
"        # Returns extra metadata, it must be a dict\n"
"        {:ok, hello: \"world\"}\n"
"      end\n"
"\n"
"      # Same as \"setup\", but receives the context\n"
"      # for the current test\n"
"      setup context do\n"
"        IO.puts \"Setting up: #{context[:test]}\"\n"
"        :ok\n"
"      end\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"\n"
"      test \"another one\", context do\n"
"        assert context[:hello] == \"world\"\n"
"      end\n"
"    end\n"
"\n"
msgstr ""
"ExUnitコールバックを定義します。\n"
"\n"
"このモジュールは、`setup_all`と`setup`コールバックの両方、\n"
"そして`on_exit`機能を定義します。\n"
"\n"
"setupコールバックはマクロとして定義され、それぞれは、\n"
"通常`context`として参照される、\n"
"メタデータのマップを、オプションで受け取ることができます。\n"
"コールバックは、オプションで、\n"
"テストで使われる追加のデータを、`context`に入れるかもしれません。\n"
"\n"
"`setup_all`コールバックは最初のテストの`setup`の前に一度だけ\n"
"起動され、それぞれのテストの前に、全ての`setup`コールバックは\n"
"走ります。テストケースがテストを持っていない、あるいは、\n"
"全てのテストがフィルタで除外されたなら、コールバックは\n"
"走りません。\n"
"\n"
"`on_exit`コールバックは、\n"
"通常、setupコールバックにより実行されたアクションを\n"
"元にもどすために、必要に応じて登録されます。\n"
"`on_exit`は、\n"
"リファレンスを取り、将来コールバックを\n"
"オーバライドすることを許すかもしれません。\n"
"`setup`と`setup_all`の失敗が、\n"
"実行中から全ての残ったsetupコールバックを停止する間、\n"
"登録された`on_exit`が常に走ります。\n"
"\n"
"最後に、`setup_all`コールバックはテストケースプロセスの中で\n"
"走り、テストそれ自身と同じプロセスで全ての`setup`コールバックは\n"
"走ります。\n"
"`on_exit`コールバックは常にテーストケースあるいは、テスト自身とは、\n"
"別のプロセスで走ります。\n"
"reason `:shutdown`でテストプロセスがexitしたとき、\n"
"殆どの場合、\n"
"プロセスがそれ自身でクリーンアプをするので、`on_exit/1`は避ける\n"
"ことができます。\n"
"\n"
"## Context\n"
"\n"
"もし`setup_all`から`{:ok, <dict>}`を返したら、\n"
"その辞書は、現在のコンテキストにマージされ、以降の全ての\n"
"`setup_all`、`setup`と、test自身で有効になります。\n"
"\n"
"同様に、`setup`から`{:ok, <dict>}`を返したら、その\n"
"返されたdictは現在のコンテキストにマージされ、以降の全ての\n"
"`setup`と`test`自身で有効になります。\n"
"\n"
"`:ok`を返すことは、両方のケースでコンテキストを変更しない\n"
"ままにします。\n"
"\n"
"`setup_all`から、それ以外を返すと、全てのテストを強制的に\n"
"失敗にし、`setup`からの悪い応答は、現在のテストを失敗を\n"
"もたらします。\n"
"\n"
"## Examples\n"
"\n"
"    defmodule AssertionTest do\n"
"      use ExUnit.Case, async: true\n"
"\n"
"      # \"setup_all\" is called once to setup the case before any test is run\n"
"      setup_all do\n"
"        IO.puts \"Starting AssertionTest\"\n"
"\n"
"        # No metadata\n"
"        :ok\n"
"      end\n"
"\n"
"      # \"setup\" is called before each test is run\n"
"      setup do\n"
"        IO.puts \"This is a setup callback\"\n"
"\n"
"        on_exit fn ->\n"
"          IO.puts \"This is invoked once the test is done\"\n"
"        end\n"
"\n"
"        # Returns extra metadata, it must be a dict\n"
"        {:ok, hello: \"world\"}\n"
"      end\n"
"\n"
"      # Same as \"setup\", but receives the context\n"
"      # for the current test\n"
"      setup context do\n"
"        IO.puts \"Setting up: #{context[:test]}\"\n"
"        :ok\n"
"      end\n"
"\n"
"      test \"always pass\" do\n"
"        assert true\n"
"      end\n"
"\n"
"      test \"another one\", context do\n"
"        assert context[:hello] == \"world\"\n"
"      end\n"
"    end\n"
"\n"
